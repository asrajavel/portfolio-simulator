{"version":3,"file":"index-59183fe4.js","sources":["../node_modules/newton-raphson-method/index.js","../node_modules/xirr/xirr.js","../src/constants/index.ts","../src/utils/date/dateUtils.ts","../src/utils/data/fillMissingNavDates.ts","../src/utils/calculations/lumpSumRollingXirr/volatility/volatilityCalculator.ts","../src/utils/calculations/lumpSumRollingXirr/index.ts"],"sourcesContent":["'use strict';\n\nmodule.exports = newtonRaphson;\n\nfunction newtonRaphson (f, fp, x0, options) {\n  var x1, y, yp, tol, maxIter, iter, yph, ymh, yp2h, ym2h, h, hr, verbose, eps;\n\n  // Iterpret variadic forms:\n  if (typeof fp !== 'function') {\n    options = x0;\n    x0 = fp;\n    fp = null;\n  }\n\n  options = options || {};\n  tol = options.tolerance === undefined ? 1e-7 : options.tolerance;\n  eps = options.epsilon === undefined ? 2.220446049250313e-16 : options.epsilon;\n  maxIter = options.maxIterations === undefined ? 20 : options.maxIterations;\n  h = options.h === undefined ? 1e-4 : options.h;\n  verbose = options.verbose === undefined ? false : options.verbose;\n  hr = 1 / h;\n\n  iter = 0;\n  while (iter++ < maxIter) {\n    // Compute the value of the function:\n    y = f(x0);\n\n    if (fp) {\n      yp = fp(x0);\n    } else {\n      // Needs numerical derivatives:\n      yph = f(x0 + h);\n      ymh = f(x0 - h);\n      yp2h = f(x0 + 2 * h);\n      ym2h = f(x0 - 2 * h);\n\n      yp = ((ym2h - yp2h) + 8 * (yph - ymh)) * hr / 12;\n    }\n\n    // Check for badly conditioned update (extremely small first deriv relative to function):\n    if (Math.abs(yp) <= eps * Math.abs(y)) {\n      if (verbose) {\n        console.log('Newton-Raphson: failed to converged due to nearly zero first derivative');\n      }\n      return false;\n    }\n\n    // Update the guess:\n    x1 = x0 - y / yp;\n\n    // Check for convergence:\n    if (Math.abs(x1 - x0) <= tol * Math.abs(x1)) {\n      if (verbose) {\n        console.log('Newton-Raphson: converged to x = ' + x1 + ' after ' + iter + ' iterations');\n      }\n      return x1;\n    }\n\n    // Transfer update to the new guess:\n    x0 = x1;\n  }\n\n  if (verbose) {\n    console.log('Newton-Raphson: Maximum iterations reached (' + maxIter + ')');\n  }\n\n  return false;\n}\n","'use strict';\n\nvar newton = require('newton-raphson-method');\n\nvar MILLIS_PER_DAY = 1000*60*60*24;\nvar DAYS_IN_YEAR = 365;\n\nfunction convert(data) {\n    if (!data || !data.length || !data.forEach || data.length < 2) {\n        throw new Error('Argument is not an array with length of 2 or more.');\n    }\n\n    var investments = [];\n    var start = Math.floor(data[0].when/MILLIS_PER_DAY);\n    var end = start;\n    var minAmount = Number.POSITIVE_INFINITY;\n    var maxAmount = Number.NEGATIVE_INFINITY;\n    var total = 0;\n    var deposits = 0;\n    data.forEach(function(datum) {\n        total += datum.amount;\n        if (datum.amount < 0) {\n            deposits += -datum.amount;\n        }\n        var epochDays = Math.floor(datum.when/MILLIS_PER_DAY);\n        start = Math.min(start, epochDays);\n        end = Math.max(end, epochDays);\n        minAmount = Math.min(minAmount, datum.amount);\n        maxAmount = Math.max(maxAmount, datum.amount);\n        investments.push({\n            amount: datum.amount,\n            epochDays: epochDays\n        });\n    });\n    if (start === end) {\n        throw new Error('Transactions must not all be on the same day.');\n    }\n    if (minAmount >= 0) {\n        throw new Error('Transactions must not all be nonnegative.');\n    }\n    if (maxAmount < 0) {\n        throw new Error('Transactions must not all be negative.');\n    }\n    investments.forEach(function(investment) {\n        // Number of years (including fraction) this item applies\n        investment.years = (end - investment.epochDays) / DAYS_IN_YEAR;\n    });\n    return {\n        total: total,\n        deposits: deposits,\n        days: end - start,\n        investments: investments,\n        maxAmount: maxAmount\n    };\n}\n\nfunction xirr(transactions, options) {\n    var data = convert(transactions);\n    if (data.maxAmount === 0) {\n        return -1;\n    }\n    var investments = data.investments;\n    var value = function(rate) {\n        return investments.reduce(function(sum, investment) {\n            // Make the vars more Math-y, makes the derivative easier to see\n            var A = investment.amount;\n            var Y = investment.years;\n            if (-1 < rate) {\n                return sum + A * Math.pow(1+rate, Y);\n            } else if (rate < -1) {\n                // Extend the function into the range where the rate is less\n                // than -100%.  Even though this does not make practical sense,\n                // it allows the algorithm to converge in the cases where the\n                // candidate values enter this range\n\n                // We cannot use the same formula as before, since the base of\n                // the exponent (1+rate) is negative, this yields imaginary\n                // values for fractional years.\n                // E.g. if rate=-1.5 and years=.5, it would be (-.5)^.5,\n                // i.e. the square root of negative one half.\n\n                // Ensure the values are always negative so there can never\n                // be a zero (as long as some amount is non-zero).\n                // This formula also ensures that the derivative is positive\n                // (when rate < -1) so that Newton's method is encouraged to \n                // move the candidate values towards the proper range\n\n                return sum - Math.abs(A) * Math.pow(-1-rate, Y);\n            } else if (Y === 0) {\n                return sum + A;  // Treat 0^0 as 1\n            } else {\n                return sum;\n            }\n        }, 0);\n    };\n    var derivative = function(rate) {\n        return investments.reduce(function(sum, investment) {\n            // Make the vars more Math-y, makes the derivative easier to see\n            var A = investment.amount;\n            var Y = investment.years;\n            if (Y === 0) {\n                return sum;\n            } else if (-1 < rate) {\n                return sum + A * Y * Math.pow(1+rate, Y-1);\n            } else if (rate < -1) {\n                return sum + Math.abs(A) * Y * Math.pow(-1-rate, Y-1);\n            } else {\n                return sum;\n            }\n        }, 0);\n    };\n    var guess = options ? options.guess : undefined;\n    if (guess && isNaN(guess)) {\n        throw new Error(\"option.guess must be a number.\");\n    }\n    if (!guess) {\n        guess = (data.total / data.deposits) / (data.days/DAYS_IN_YEAR);\n    }\n    var rate = newton(value, derivative, guess, options);\n    if (rate === false) {  // truthiness strikes again, !rate is true when rate is zero\n        throw new Error(\"Newton-Raphson algorithm failed to converge.\");\n    }\n    return rate;\n}\n\nmodule.exports = xirr;\n","// Application constants\nexport const DEFAULT_SCHEME_CODE = 120716;\nexport const DEFAULT_REBALANCING_THRESHOLD = 5;\n\n// API Configuration\nexport const API_ENDPOINTS = {\n  MFAPI_BASE: 'https://api.mfapi.in',\n  YAHOO_FINANCE_PROXY: 'https://api.allorigins.win/get?url=',\n  INDEX_DATA_BASE: 'https://raw.githubusercontent.com/asrajavel/mf-index-data/main'\n} as const;\n\n// UI Configuration\nexport const COLORS = [\n  '#007bff', '#28a745', '#ff9800', '#e91e63', \n  '#9c27b0', '#00bcd4', '#795548', '#607d8b'\n];\n\n// Validation\nexport const ALLOCATION_TOTAL = 100;\nexport const MIN_ALLOCATION = 0;\nexport const MAX_ALLOCATION = 100;\n\n// Date calculations\nexport const MILLISECONDS_PER_DAY = 1000 * 60 * 60 * 24;\nexport const MONTHS_PER_YEAR = 12;\n\n// Chart Styling Configuration\nexport const CHART_STYLES = {\n  title: {\n    fontSize: '18px',\n    fontWeight: '600',\n    color: '#1f2937',\n    fontFamily: 'system-ui, -apple-system, sans-serif'\n  },\n  axisTitle: {\n    fontSize: '14px',\n    fontWeight: '500',\n    color: '#6b7280',\n    fontFamily: 'system-ui, -apple-system, sans-serif'\n  },\n  axisLabels: {\n    fontSize: '12px',\n    color: '#6b7280',\n    fontFamily: 'system-ui, -apple-system, sans-serif'\n  },\n  legend: {\n    fontSize: '13px',\n    fontWeight: '500',\n    color: '#374151'\n  },\n  tooltip: {\n    fontSize: '12px',\n    color: '#ffffff'\n  },\n  colors: {\n    gridLine: '#f3f4f6',\n    line: '#e5e7eb',\n    tick: '#e5e7eb',\n    background: '#ffffff',\n    tooltipBackground: '#1f2937'\n  }\n} as const;\n","// Date utility functions for NAV and lump sum rolling XIRR calculations\nimport { NavEntry } from '../../types/navData';\nimport { MILLISECONDS_PER_DAY } from '../../constants';\n\nexport function areDatesContinuous(navData: NavEntry[]): boolean {\n  if (navData.length < 2) return true;\n  const sorted = [...navData].sort((a, b) => a.date.getTime() - b.date.getTime());\n  for (let i = 1; i < sorted.length; i++) {\n    const prev = sorted[i - 1].date;\n    const curr = sorted[i].date;\n    const diff = (curr.getTime() - prev.getTime()) / MILLISECONDS_PER_DAY;\n    if (diff !== 1) return false;\n  }\n  return true;\n}\n\n// Get the date N months before a given date, handling month-end edge cases\nexport function getNthPreviousMonthDate(currentDate: Date, months: number): Date {\n  const date = new Date(currentDate);\n  const d = date.getDate();\n  date.setMonth(date.getMonth() - months);\n  // Handle month-end edge case (e.g., March 31 -> Feb 28/29)\n  if (date.getDate() < d) {\n    date.setDate(0); // Go to last day of previous month\n  }\n  return date;\n} ","import { NavEntry } from '../../types/navData';\n\nexport function fillMissingNavDates(navData: NavEntry[]): NavEntry[] {\n  if (navData.length === 0) return [];\n\n  // Sort ascending (oldest first)\n  const sorted = [...navData].sort((a, b) => a.date.getTime() - b.date.getTime());\n  const filled: NavEntry[] = [];\n  let i = 0;\n  let current = new Date(sorted[0].date);\n  const last = sorted[sorted.length - 1].date;\n\n  while (current <= last) {\n    if (i < sorted.length && sameDay(current, sorted[i].date)) {\n      filled.push({ date: new Date(current), nav: sorted[i].nav });\n      i++;\n    } else {\n      // Use the next available NAV (forward fill)\n      filled.push({ date: new Date(current), nav: sorted[i].nav });\n    }\n    current.setDate(current.getDate() + 1);\n  }\n  return filled;\n}\n\nfunction sameDay(a: Date, b: Date) {\n  return a.getFullYear() === b.getFullYear() &&\n    a.getMonth() === b.getMonth() &&\n    a.getDate() === b.getDate();\n} ","const TRADING_DAYS_PER_YEAR = 252;\n\nexport interface DailyPortfolioValue {\n  date: Date;\n  totalValue: number;\n}\n\n/**\n * Calculate portfolio volatility from daily portfolio values\n * Returns annualized volatility as a percentage\n * \n * Lumpsum version is simpler than SIP since there are no intermediate cash flows\n * to adjust for - just a single investment at start\n */\nexport function calculateVolatility(\n  dailyValues: DailyPortfolioValue[]\n): number {\n  // Need at least 2 data points to calculate volatility\n  if (dailyValues.length < 2) {\n    return 0;\n  }\n\n  // Calculate daily returns\n  const dailyReturns = calculateDailyReturns(dailyValues);\n\n  // Need at least 2 returns to calculate volatility\n  if (dailyReturns.length < 2) {\n    return 0;\n  }\n\n  // Calculate mean return\n  const meanReturn = dailyReturns.reduce((sum, r) => sum + r, 0) / dailyReturns.length;\n\n  // Calculate variance\n  const variance = dailyReturns.reduce((sum, r) => {\n    const diff = r - meanReturn;\n    return sum + (diff * diff);\n  }, 0) / dailyReturns.length;\n\n  // Calculate standard deviation (daily volatility)\n  const dailyVolatility = Math.sqrt(variance);\n\n  // Calculate trading days per year based on actual data\n  // If we have 365 days but only 252 returns (after skipping weekends), annualize accordingly\n  const totalDays = dailyValues.length - 1; // Total day-pairs\n  const tradingDays = dailyReturns.length;   // Actual trading days (non-zero returns)\n  const tradingDaysPerYear = totalDays > 0 \n    ? Math.round((tradingDays / totalDays) * 365)\n    : TRADING_DAYS_PER_YEAR; // Default to 252 if calculation fails\n\n  // Annualize volatility using calculated trading days\n  const annualizedVolatility = dailyVolatility * Math.sqrt(tradingDaysPerYear);\n\n  const volatilityPercent = (annualizedVolatility * 100) || 0;\n\n  return volatilityPercent;\n}\n\n/**\n * Calculate daily returns from portfolio values\n * Daily Return = (Today's Value / Yesterday's Value) - 1\n * \n * Simpler than SIP since lumpsum has no intermediate cash flows\n * Just pure market returns on the invested capital\n * \n * Skips forward-filled days (weekends/holidays) where value didn't change\n * This prevents artificially low volatility from zero returns on non-trading days\n */\nfunction calculateDailyReturns(dailyValues: DailyPortfolioValue[]): number[] {\n  const returns: number[] = [];\n\n  for (let i = 1; i < dailyValues.length; i++) {\n    const previousValue = dailyValues[i - 1].totalValue;\n    const currentValue = dailyValues[i].totalValue;\n\n    if (previousValue > 0) {\n      // Skip forward-filled days (weekends/holidays) where value didn't change\n      // This prevents artificially low volatility from zero returns on non-trading days\n      if (currentValue === previousValue) {\n        continue;\n      }\n      \n      const dailyReturn = (currentValue / previousValue) - 1;\n      returns.push(dailyReturn);\n    }\n  }\n\n  return returns;\n}\n","import xirr from 'xirr';\nimport { NavEntry } from '../../../types/navData';\nimport { areDatesContinuous, getNthPreviousMonthDate } from '../../date/dateUtils';\nimport { fillMissingNavDates } from '../../data/fillMissingNavDates';\nimport { calculateVolatility, DailyPortfolioValue } from './volatility/volatilityCalculator';\nimport { Transaction } from '../sipRollingXirr/types';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface RollingXirrEntry {\n  date: Date;\n  xirr: number;\n  transactions: Transaction[];\n  volatility?: number;\n}\n\n// Re-export Transaction for convenience\nexport type { Transaction } from '../sipRollingXirr/types';\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\nfunction toDateKey(date: Date): string {\n  return date.toISOString().split('T')[0];\n}\n\nfunction buildDateMap(fund: NavEntry[]): Map<string, NavEntry> {\n  return new Map(fund.map(entry => [toDateKey(entry.date), entry]));\n}\n\nfunction ensureContinuousDates(fund: NavEntry[]): NavEntry[] {\n  return areDatesContinuous(fund) ? fund : fillMissingNavDates(fund);\n}\n\nfunction isValidInput(navDataList: NavEntry[][]): boolean {\n  return navDataList.length > 0 && navDataList.every(fund => fund.length >= 2);\n}\n\nfunction getSortedDates(fund: NavEntry[]): NavEntry[] {\n  return [...fund].sort((a, b) => a.date.getTime() - b.date.getTime());\n}\n\n// ============================================================================\n// MAIN CALCULATION FUNCTION (OPTIMIZED)\n// ============================================================================\n\n/**\n * Calculate Lumpsum Rolling XIRR for given NAV data\n * \n * OPTIMIZATION: Pre-computes daily portfolio values once for the entire date range,\n * then slices for each rolling window instead of recalculating.\n * This reduces complexity from O(windows × daysPerWindow) to O(totalDays).\n * \n * @param navDataList - Array of NAV data for each fund\n * @param years - Rolling period in years (default: 1)\n * @param allocations - Target allocation percentages for each fund (default: equal split)\n * @param investmentAmount - Total investment amount (default: 100)\n * @param includeNilTransactions - Whether to include nil transactions in result (default: false)\n * @returns Array of Lumpsum Rolling XIRR entries for each date\n */\n// Timing accumulators for performance analysis\nlet _xirrTime = 0;\nlet _volatilityTime = 0;\nlet _precomputeTime = 0;\n\nexport function calculateLumpSumRollingXirr(\n  navDataList: NavEntry[][],\n  years: number = 1,\n  allocations: number[] = [],\n  investmentAmount: number = 100,\n  includeNilTransactions: boolean = false\n): RollingXirrEntry[] {\n  // Reset timing accumulators\n  _xirrTime = 0;\n  _volatilityTime = 0;\n  _precomputeTime = 0;\n  \n  // Validate input\n  if (!isValidInput(navDataList)) return [];\n\n  // Prepare data\n  const numFunds = navDataList.length;\n  const actualAllocations = allocations.length === numFunds \n    ? allocations \n    : Array(numFunds).fill(100 / numFunds);\n  \n  const filledNavs = navDataList.map(ensureContinuousDates);\n  const fundDateMaps = filledNavs.map(buildDateMap);\n  const sorted = getSortedDates(filledNavs[0]);\n  const firstDate = sorted[0].date;\n  const months = years * 12;\n\n  // Build date index map for fast lookups\n  const dateIndexMap = new Map<string, number>();\n  sorted.forEach((entry, idx) => {\n    dateIndexMap.set(toDateKey(entry.date), idx);\n  });\n\n  // Pre-compute raw NAVs per fund per date for fast lookups\n  // We store NAVs instead of normalized values because portfolio value calculation\n  // requires NAV ratios relative to each window's start date, not a global base date.\n  // For multi-fund portfolios: Value[date] = Σ(alloc[f] × NAV[f,date] / NAV[f,startDate]) × investment\n  const precomputeStart = performance.now();\n  \n  // Build array of NAVs per date: allNavs[dateIdx][fundIdx] = NAV\n  const allNavs: number[][] = [];\n  for (const entry of sorted) {\n    const dateKey = toDateKey(entry.date);\n    const navsForDate: number[] = [];\n    for (let f = 0; f < numFunds; f++) {\n      const navEntry = fundDateMaps[f].get(dateKey);\n      navsForDate.push(navEntry?.nav ?? 0);\n    }\n    allNavs.push(navsForDate);\n  }\n  _precomputeTime = performance.now() - precomputeStart;\n\n  // Calculate XIRR for each date\n  const results: RollingXirrEntry[] = [];\n  \n  for (let i = 0; i < sorted.length; i++) {\n    const endDate = sorted[i].date;\n    const startDate = getNthPreviousMonthDate(endDate, months);\n    if (startDate < firstDate) continue;\n    \n    const startKey = toDateKey(startDate);\n    const startIdx = dateIndexMap.get(startKey);\n    if (startIdx === undefined) continue;\n    \n    // Calculate units purchased at start for each fund\n    const fundUnits = calculateFundUnits(fundDateMaps, startDate, actualAllocations, investmentAmount);\n    if (!fundUnits) continue;\n    \n    // Calculate total portfolio value at end date\n    const totalValue = calculateTotalValue(fundDateMaps, endDate, fundUnits);\n    if (totalValue === null) continue;\n    \n    // Calculate XIRR (timed)\n    const xirrStart = performance.now();\n    const xirrValue = calculateXirr(investmentAmount, totalValue, startDate, endDate);\n    _xirrTime += performance.now() - xirrStart;\n    if (xirrValue === null) continue;\n    \n    // Calculate volatility using pre-computed NAVs (timed)\n    // For each date in the window, compute portfolio value using correct formula:\n    // Value[date] = Σ(alloc[f] × NAV[f,date] / NAV[f,startDate]) × investment\n    const volStart = performance.now();\n    const startNavs = allNavs[startIdx];\n    const dailyValues: DailyPortfolioValue[] = [];\n    \n    for (let j = startIdx; j <= i; j++) {\n      const dateNavs = allNavs[j];\n      let portfolioValue = 0;\n      for (let f = 0; f < numFunds; f++) {\n        if (startNavs[f] > 0) {\n          portfolioValue += (actualAllocations[f] / 100) * (dateNavs[f] / startNavs[f]) * investmentAmount;\n        }\n      }\n      dailyValues.push({ date: sorted[j].date, totalValue: portfolioValue });\n    }\n    const volatility = calculateVolatility(dailyValues);\n    _volatilityTime += performance.now() - volStart;\n    \n    // Build only buy/sell transactions (skip nil - major performance gain)\n    const transactions = buildBuySellTransactions(\n      fundDateMaps,\n      fundUnits,\n      actualAllocations,\n      startDate,\n      endDate,\n      investmentAmount\n    );\n    \n    results.push({\n      date: endDate,\n      xirr: Math.round(xirrValue * 10000) / 10000,\n      transactions,\n      volatility: Math.round(volatility * 10000) / 10000\n    });\n  }\n  \n  // Log timing breakdown\n  console.log(`[Lumpsum Calc] Precompute: ${(_precomputeTime / 1000).toFixed(2)}s | XIRR: ${(_xirrTime / 1000).toFixed(2)}s | Volatility: ${(_volatilityTime / 1000).toFixed(2)}s | Total entries: ${results.length}`);\n  \n  return results;\n}\n\n/**\n * Build only buy and sell transactions (skip nil transactions for performance)\n * This is used for corpus value calculation in charts\n */\nfunction buildBuySellTransactions(\n  fundDateMaps: Map<string, NavEntry>[],\n  fundUnits: number[],\n  allocations: number[],\n  startDate: Date,\n  endDate: Date,\n  investmentAmount: number\n): Transaction[] {\n  const transactions: Transaction[] = [];\n  const startKey = toDateKey(startDate);\n  const endKey = toDateKey(endDate);\n  \n  // Build buy transactions (start date)\n  let startPortfolioValue = 0;\n  for (let fundIdx = 0; fundIdx < fundDateMaps.length; fundIdx++) {\n    const navEntry = fundDateMaps[fundIdx].get(startKey);\n    if (!navEntry) continue;\n    \n    const currentValue = fundUnits[fundIdx] * navEntry.nav;\n    startPortfolioValue += currentValue;\n    const fundAllocation = (investmentAmount * allocations[fundIdx]) / 100;\n    \n    transactions.push({\n      fundIdx,\n      nav: navEntry.nav,\n      when: navEntry.date,\n      units: fundUnits[fundIdx],\n      amount: -fundAllocation,\n      type: 'buy',\n      cumulativeUnits: fundUnits[fundIdx],\n      currentValue,\n      allocationPercentage: 0\n    });\n  }\n  \n  // Build sell transactions (end date)\n  let endPortfolioValue = 0;\n  const sellTransactions: Transaction[] = [];\n  for (let fundIdx = 0; fundIdx < fundDateMaps.length; fundIdx++) {\n    const navEntry = fundDateMaps[fundIdx].get(endKey);\n    if (!navEntry) continue;\n    \n    const currentValue = fundUnits[fundIdx] * navEntry.nav;\n    endPortfolioValue += currentValue;\n    \n    sellTransactions.push({\n      fundIdx,\n      nav: navEntry.nav,\n      when: navEntry.date,\n      units: fundUnits[fundIdx],\n      amount: currentValue,\n      type: 'sell',\n      cumulativeUnits: fundUnits[fundIdx],\n      currentValue,\n      allocationPercentage: 0\n    });\n  }\n  \n  // Calculate allocation percentages\n  transactions.forEach(tx => {\n    tx.allocationPercentage = startPortfolioValue > 0 \n      ? (tx.currentValue / startPortfolioValue) * 100 \n      : 0;\n  });\n  sellTransactions.forEach(tx => {\n    tx.allocationPercentage = endPortfolioValue > 0 \n      ? (tx.currentValue / endPortfolioValue) * 100 \n      : 0;\n  });\n  \n  transactions.push(...sellTransactions);\n  return transactions;\n}\n\n/**\n * Calculate units purchased for each fund at start date\n */\nfunction calculateFundUnits(\n  fundDateMaps: Map<string, NavEntry>[],\n  startDate: Date,\n  allocations: number[],\n  investmentAmount: number\n): number[] | null {\n  const fundUnits: number[] = [];\n  const startKey = toDateKey(startDate);\n\n  for (let f = 0; f < fundDateMaps.length; f++) {\n    const startEntry = fundDateMaps[f].get(startKey);\n    if (!startEntry) return null;\n    \n    const fundAllocation = (investmentAmount * allocations[f]) / 100;\n    fundUnits[f] = fundAllocation / startEntry.nav;\n  }\n\n  return fundUnits;\n}\n\n/**\n * Calculate total portfolio value at end date\n */\nfunction calculateTotalValue(\n  fundDateMaps: Map<string, NavEntry>[],\n  endDate: Date,\n  fundUnits: number[]\n): number | null {\n  let totalValue = 0;\n  const endKey = toDateKey(endDate);\n\n  for (let f = 0; f < fundDateMaps.length; f++) {\n    const endEntry = fundDateMaps[f].get(endKey);\n    if (!endEntry) return null;\n    \n    totalValue += fundUnits[f] * endEntry.nav;\n  }\n\n  return totalValue;\n}\n\n/**\n * Calculate XIRR from initial investment and final value\n */\nfunction calculateXirr(\n  investmentAmount: number,\n  totalValue: number,\n  startDate: Date,\n  endDate: Date\n): number | null {\n  try {\n    return xirr([\n      { amount: -investmentAmount, when: startDate },\n      { amount: totalValue, when: endDate }\n    ]);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Build detailed transactions for all dates in the period\n */\nfunction buildDetailedTransactions(\n  fundDateMaps: Map<string, NavEntry>[],\n  fundUnits: number[],\n  allocations: number[],\n  sorted: NavEntry[],\n  startDate: Date,\n  endDate: Date,\n  investmentAmount: number\n): Transaction[] {\n  const transactions: Transaction[] = [];\n  const startKey = toDateKey(startDate);\n  const endKey = toDateKey(endDate);\n  \n  // Filter dates within the period\n  const periodDates = sorted.filter(\n    entry => entry.date >= startDate && entry.date <= endDate\n  );\n  \n  // Generate transactions for each day\n  for (const dateEntry of periodDates) {\n    const dateKey = toDateKey(dateEntry.date);\n    const isStartDate = dateKey === startKey;\n    const isEndDate = dateKey === endKey;\n    let totalPortfolioValue = 0;\n    const dayTransactions: Transaction[] = [];\n\n    // Create transaction for each fund\n    for (let fundIdx = 0; fundIdx < fundDateMaps.length; fundIdx++) {\n      const navEntry = fundDateMaps[fundIdx].get(dateKey);\n      if (!navEntry) continue;\n\n      const currentValue = fundUnits[fundIdx] * navEntry.nav;\n      totalPortfolioValue += currentValue;\n      const fundAllocation = (investmentAmount * allocations[fundIdx]) / 100;\n      \n      // Determine transaction type, amount, and units\n      let type: 'buy' | 'sell' | 'nil' = 'nil';\n      let amount = 0;\n      let units = 0; // nil transactions have 0 units (no transaction happening)\n      \n      if (isStartDate) {\n        type = 'buy';\n        amount = -fundAllocation;\n        units = fundUnits[fundIdx]; // buying these units\n      } else if (isEndDate) {\n        type = 'sell';\n        amount = currentValue;\n        units = fundUnits[fundIdx]; // selling these units\n      }\n\n      dayTransactions.push({\n        fundIdx,\n        nav: navEntry.nav,\n        when: navEntry.date,\n        units,\n        amount,\n        type,\n        cumulativeUnits: fundUnits[fundIdx], // total units held\n        currentValue,\n        allocationPercentage: 0 // Calculated below\n      });\n    }\n\n    // Calculate allocation percentages\n    dayTransactions.forEach(tx => {\n      tx.allocationPercentage = totalPortfolioValue > 0 \n        ? (tx.currentValue / totalPortfolioValue) * 100 \n        : 0;\n    });\n\n    transactions.push(...dayTransactions);\n  }\n\n  return transactions;\n}\n\n// ============================================================================\n// ON-DEMAND RECALCULATION\n// ============================================================================\n\n/**\n * Recalculate transactions for a specific date with nil transactions included\n * Used for on-demand calculation when viewing transaction details in modal\n * \n * @param navDataList - Array of NAV data for each fund\n * @param targetDate - The specific date to recalculate for\n * @param years - Rolling period in years\n * @param allocations - Target allocation percentages for each fund\n * @param investmentAmount - Total investment amount\n * @returns Transaction array with nil transactions included, or null if calculation fails\n */\nexport function recalculateLumpsumTransactionsForDate(\n  navDataList: NavEntry[][],\n  targetDate: Date,\n  years: number,\n  allocations: number[],\n  investmentAmount: number = 100\n): Transaction[] | null {\n  // Validate input\n  if (!isValidInput(navDataList)) return null;\n\n  // Prepare data\n  const numFunds = navDataList.length;\n  const actualAllocations = allocations.length === numFunds \n    ? allocations \n    : Array(numFunds).fill(100 / numFunds);\n  \n  const filledNavs = navDataList.map(ensureContinuousDates);\n  const fundDateMaps = filledNavs.map(buildDateMap);\n  const sorted = getSortedDates(filledNavs[0]);\n  const firstDate = sorted[0].date;\n  const months = years * 12;\n\n  // Calculate start date\n  const startDate = getNthPreviousMonthDate(targetDate, months);\n  if (startDate < firstDate) return null;\n\n  // Calculate fund units\n  const fundUnits = calculateFundUnits(\n    fundDateMaps,\n    startDate,\n    actualAllocations,\n    investmentAmount\n  );\n  if (!fundUnits) return null;\n\n  // Build detailed transactions (with nil included)\n  const allTransactions = buildDetailedTransactions(\n    fundDateMaps,\n    fundUnits,\n    actualAllocations,\n    sorted,\n    startDate,\n    targetDate,\n    investmentAmount\n  );\n\n  return allTransactions;\n}\n"],"names":["newtonRaphsonMethod","newtonRaphson","f","fp","x0","options","x1","y","yp","tol","maxIter","iter","yph","ymh","yp2h","ym2h","h","hr","verbose","eps","newton","require$$0","MILLIS_PER_DAY","DAYS_IN_YEAR","convert","data","investments","start","end","minAmount","maxAmount","total","deposits","datum","epochDays","investment","xirr","transactions","value","rate","sum","A","Y","derivative","guess","xirr_1","MILLISECONDS_PER_DAY","areDatesContinuous","navData","sorted","a","b","i","prev","getNthPreviousMonthDate","currentDate","months","date","d","fillMissingNavDates","filled","current","last","sameDay","TRADING_DAYS_PER_YEAR","calculateVolatility","dailyValues","dailyReturns","calculateDailyReturns","meanReturn","r","variance","diff","dailyVolatility","totalDays","tradingDays","tradingDaysPerYear","returns","previousValue","currentValue","dailyReturn","toDateKey","buildDateMap","fund","entry","ensureContinuousDates","isValidInput","navDataList","getSortedDates","_xirrTime","_volatilityTime","_precomputeTime","calculateLumpSumRollingXirr","years","allocations","investmentAmount","includeNilTransactions","numFunds","actualAllocations","filledNavs","fundDateMaps","firstDate","dateIndexMap","idx","precomputeStart","allNavs","dateKey","navsForDate","navEntry","results","endDate","startDate","startKey","startIdx","fundUnits","calculateFundUnits","totalValue","calculateTotalValue","xirrStart","xirrValue","calculateXirr","volStart","startNavs","j","dateNavs","portfolioValue","volatility","buildBuySellTransactions","endKey","startPortfolioValue","fundIdx","fundAllocation","endPortfolioValue","sellTransactions","tx","startEntry","endEntry","buildDetailedTransactions","periodDates","dateEntry","isStartDate","isEndDate","totalPortfolioValue","dayTransactions","type","amount","units","recalculateLumpsumTransactionsForDate","targetDate"],"mappings":"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","x_google_ignoreList":[0,1]}