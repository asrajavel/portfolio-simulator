{"version":3,"file":"index-ffe347d8.js","sources":["../node_modules/newton-raphson-method/index.js","../node_modules/xirr/xirr.js","../src/constants/index.ts","../src/utils/date/dateUtils.ts","../src/utils/data/fillMissingNavDates.ts","../src/utils/calculations/lumpSumRollingXirr/index.ts"],"sourcesContent":["'use strict';\n\nmodule.exports = newtonRaphson;\n\nfunction newtonRaphson (f, fp, x0, options) {\n  var x1, y, yp, tol, maxIter, iter, yph, ymh, yp2h, ym2h, h, hr, verbose, eps;\n\n  // Iterpret variadic forms:\n  if (typeof fp !== 'function') {\n    options = x0;\n    x0 = fp;\n    fp = null;\n  }\n\n  options = options || {};\n  tol = options.tolerance === undefined ? 1e-7 : options.tolerance;\n  eps = options.epsilon === undefined ? 2.220446049250313e-16 : options.epsilon;\n  maxIter = options.maxIterations === undefined ? 20 : options.maxIterations;\n  h = options.h === undefined ? 1e-4 : options.h;\n  verbose = options.verbose === undefined ? false : options.verbose;\n  hr = 1 / h;\n\n  iter = 0;\n  while (iter++ < maxIter) {\n    // Compute the value of the function:\n    y = f(x0);\n\n    if (fp) {\n      yp = fp(x0);\n    } else {\n      // Needs numerical derivatives:\n      yph = f(x0 + h);\n      ymh = f(x0 - h);\n      yp2h = f(x0 + 2 * h);\n      ym2h = f(x0 - 2 * h);\n\n      yp = ((ym2h - yp2h) + 8 * (yph - ymh)) * hr / 12;\n    }\n\n    // Check for badly conditioned update (extremely small first deriv relative to function):\n    if (Math.abs(yp) <= eps * Math.abs(y)) {\n      if (verbose) {\n        console.log('Newton-Raphson: failed to converged due to nearly zero first derivative');\n      }\n      return false;\n    }\n\n    // Update the guess:\n    x1 = x0 - y / yp;\n\n    // Check for convergence:\n    if (Math.abs(x1 - x0) <= tol * Math.abs(x1)) {\n      if (verbose) {\n        console.log('Newton-Raphson: converged to x = ' + x1 + ' after ' + iter + ' iterations');\n      }\n      return x1;\n    }\n\n    // Transfer update to the new guess:\n    x0 = x1;\n  }\n\n  if (verbose) {\n    console.log('Newton-Raphson: Maximum iterations reached (' + maxIter + ')');\n  }\n\n  return false;\n}\n","'use strict';\n\nvar newton = require('newton-raphson-method');\n\nvar MILLIS_PER_DAY = 1000*60*60*24;\nvar DAYS_IN_YEAR = 365;\n\nfunction convert(data) {\n    if (!data || !data.length || !data.forEach || data.length < 2) {\n        throw new Error('Argument is not an array with length of 2 or more.');\n    }\n\n    var investments = [];\n    var start = Math.floor(data[0].when/MILLIS_PER_DAY);\n    var end = start;\n    var minAmount = Number.POSITIVE_INFINITY;\n    var maxAmount = Number.NEGATIVE_INFINITY;\n    var total = 0;\n    var deposits = 0;\n    data.forEach(function(datum) {\n        total += datum.amount;\n        if (datum.amount < 0) {\n            deposits += -datum.amount;\n        }\n        var epochDays = Math.floor(datum.when/MILLIS_PER_DAY);\n        start = Math.min(start, epochDays);\n        end = Math.max(end, epochDays);\n        minAmount = Math.min(minAmount, datum.amount);\n        maxAmount = Math.max(maxAmount, datum.amount);\n        investments.push({\n            amount: datum.amount,\n            epochDays: epochDays\n        });\n    });\n    if (start === end) {\n        throw new Error('Transactions must not all be on the same day.');\n    }\n    if (minAmount >= 0) {\n        throw new Error('Transactions must not all be nonnegative.');\n    }\n    if (maxAmount < 0) {\n        throw new Error('Transactions must not all be negative.');\n    }\n    investments.forEach(function(investment) {\n        // Number of years (including fraction) this item applies\n        investment.years = (end - investment.epochDays) / DAYS_IN_YEAR;\n    });\n    return {\n        total: total,\n        deposits: deposits,\n        days: end - start,\n        investments: investments,\n        maxAmount: maxAmount\n    };\n}\n\nfunction xirr(transactions, options) {\n    var data = convert(transactions);\n    if (data.maxAmount === 0) {\n        return -1;\n    }\n    var investments = data.investments;\n    var value = function(rate) {\n        return investments.reduce(function(sum, investment) {\n            // Make the vars more Math-y, makes the derivative easier to see\n            var A = investment.amount;\n            var Y = investment.years;\n            if (-1 < rate) {\n                return sum + A * Math.pow(1+rate, Y);\n            } else if (rate < -1) {\n                // Extend the function into the range where the rate is less\n                // than -100%.  Even though this does not make practical sense,\n                // it allows the algorithm to converge in the cases where the\n                // candidate values enter this range\n\n                // We cannot use the same formula as before, since the base of\n                // the exponent (1+rate) is negative, this yields imaginary\n                // values for fractional years.\n                // E.g. if rate=-1.5 and years=.5, it would be (-.5)^.5,\n                // i.e. the square root of negative one half.\n\n                // Ensure the values are always negative so there can never\n                // be a zero (as long as some amount is non-zero).\n                // This formula also ensures that the derivative is positive\n                // (when rate < -1) so that Newton's method is encouraged to \n                // move the candidate values towards the proper range\n\n                return sum - Math.abs(A) * Math.pow(-1-rate, Y);\n            } else if (Y === 0) {\n                return sum + A;  // Treat 0^0 as 1\n            } else {\n                return sum;\n            }\n        }, 0);\n    };\n    var derivative = function(rate) {\n        return investments.reduce(function(sum, investment) {\n            // Make the vars more Math-y, makes the derivative easier to see\n            var A = investment.amount;\n            var Y = investment.years;\n            if (Y === 0) {\n                return sum;\n            } else if (-1 < rate) {\n                return sum + A * Y * Math.pow(1+rate, Y-1);\n            } else if (rate < -1) {\n                return sum + Math.abs(A) * Y * Math.pow(-1-rate, Y-1);\n            } else {\n                return sum;\n            }\n        }, 0);\n    };\n    var guess = options ? options.guess : undefined;\n    if (guess && isNaN(guess)) {\n        throw new Error(\"option.guess must be a number.\");\n    }\n    if (!guess) {\n        guess = (data.total / data.deposits) / (data.days/DAYS_IN_YEAR);\n    }\n    var rate = newton(value, derivative, guess, options);\n    if (rate === false) {  // truthiness strikes again, !rate is true when rate is zero\n        throw new Error(\"Newton-Raphson algorithm failed to converge.\");\n    }\n    return rate;\n}\n\nmodule.exports = xirr;\n","// Application constants\nexport const DEFAULT_SCHEME_CODE = 120716;\nexport const DEFAULT_REBALANCING_THRESHOLD = 5;\n\n// API Configuration\nexport const API_ENDPOINTS = {\n  MFAPI_BASE: 'https://api.mfapi.in',\n  YAHOO_FINANCE_PROXY: 'https://api.allorigins.win/get?url=',\n  INDEX_DATA_BASE: 'https://raw.githubusercontent.com/asrajavel/mf-index-data/main'\n} as const;\n\n// UI Configuration\nexport const COLORS = [\n  '#007bff', '#28a745', '#ff9800', '#e91e63', \n  '#9c27b0', '#00bcd4', '#795548', '#607d8b'\n];\n\n// Validation\nexport const ALLOCATION_TOTAL = 100;\nexport const MIN_ALLOCATION = 0;\nexport const MAX_ALLOCATION = 100;\n\n// Date calculations\nexport const MILLISECONDS_PER_DAY = 1000 * 60 * 60 * 24;\nexport const MONTHS_PER_YEAR = 12;\n\n// Chart Styling Configuration\nexport const CHART_STYLES = {\n  title: {\n    fontSize: '18px',\n    fontWeight: '600',\n    color: '#1f2937',\n    fontFamily: 'system-ui, -apple-system, sans-serif'\n  },\n  axisTitle: {\n    fontSize: '14px',\n    fontWeight: '500',\n    color: '#6b7280',\n    fontFamily: 'system-ui, -apple-system, sans-serif'\n  },\n  axisLabels: {\n    fontSize: '12px',\n    color: '#6b7280',\n    fontFamily: 'system-ui, -apple-system, sans-serif'\n  },\n  legend: {\n    fontSize: '13px',\n    fontWeight: '500',\n    color: '#374151'\n  },\n  tooltip: {\n    fontSize: '12px',\n    color: '#ffffff'\n  },\n  colors: {\n    gridLine: '#f3f4f6',\n    line: '#e5e7eb',\n    tick: '#e5e7eb',\n    background: '#ffffff',\n    tooltipBackground: '#1f2937'\n  }\n} as const;\n","// Date utility functions for NAV and lump sum rolling XIRR calculations\nimport { NavEntry } from '../../types/navData';\nimport { MILLISECONDS_PER_DAY } from '../../constants';\n\nexport function areDatesContinuous(navData: NavEntry[]): boolean {\n  if (navData.length < 2) return true;\n  const sorted = [...navData].sort((a, b) => a.date.getTime() - b.date.getTime());\n  for (let i = 1; i < sorted.length; i++) {\n    const prev = sorted[i - 1].date;\n    const curr = sorted[i].date;\n    const diff = (curr.getTime() - prev.getTime()) / MILLISECONDS_PER_DAY;\n    if (diff !== 1) return false;\n  }\n  return true;\n}\n\n// Get the date N months before a given date, handling month-end edge cases\nexport function getNthPreviousMonthDate(currentDate: Date, months: number): Date {\n  const date = new Date(currentDate);\n  const d = date.getDate();\n  date.setMonth(date.getMonth() - months);\n  // Handle month-end edge case (e.g., March 31 -> Feb 28/29)\n  if (date.getDate() < d) {\n    date.setDate(0); // Go to last day of previous month\n  }\n  return date;\n} ","import { NavEntry } from '../../types/navData';\n\nexport function fillMissingNavDates(navData: NavEntry[]): NavEntry[] {\n  if (navData.length === 0) return [];\n\n  // Sort ascending (oldest first)\n  const sorted = [...navData].sort((a, b) => a.date.getTime() - b.date.getTime());\n  const filled: NavEntry[] = [];\n  let i = 0;\n  let current = new Date(sorted[0].date);\n  const last = sorted[sorted.length - 1].date;\n\n  while (current <= last) {\n    if (i < sorted.length && sameDay(current, sorted[i].date)) {\n      filled.push({ date: new Date(current), nav: sorted[i].nav });\n      i++;\n    } else {\n      // Use the next available NAV (forward fill)\n      filled.push({ date: new Date(current), nav: sorted[i].nav });\n    }\n    current.setDate(current.getDate() + 1);\n  }\n  return filled;\n}\n\nfunction sameDay(a: Date, b: Date) {\n  return a.getFullYear() === b.getFullYear() &&\n    a.getMonth() === b.getMonth() &&\n    a.getDate() === b.getDate();\n} ","import xirr from 'xirr';\nimport { NavEntry } from '../../../types/navData';\nimport { areDatesContinuous, getNthPreviousMonthDate } from '../../date/dateUtils';\nimport { fillMissingNavDates } from '../../data/fillMissingNavDates';\n\n/**\n * Helper to create a date key for map lookups (same as SIP)\n */\nfunction toDateKey(date: Date): string {\n  return date.toISOString().split('T')[0];\n}\n\n/**\n * Helper to build a date map for O(1) lookups (same as SIP)\n */\nfunction buildDateMap(fund: NavEntry[]): Map<string, NavEntry> {\n  return new Map(fund.map(entry => [toDateKey(entry.date), entry]));\n}\n\nexport interface RollingXirrEntry {\n  date: Date;\n  xirr: number;\n  transactions: { nav: number; when: Date }[];\n  volatility?: number;\n}\n\n/**\n * Calculates lump sum rolling XIRR for a portfolio of funds.\n * Each fund's NAV data should be provided as an array in the input array.\n * Investments are allocated according to the allocations array.\n *\n * @param navDataList Array of arrays of NavEntry (one per fund)\n * @param years Rolling window size in years (default 1)\n * @param allocations Array of allocation percentages (default: equal split)\n * @param investmentAmount Total investment amount (default 100)\n */\nexport function calculateLumpSumRollingXirr(\n  navDataList: NavEntry[][],\n  years: number = 1,\n  allocations: number[] = [],\n  investmentAmount: number = 100\n): RollingXirrEntry[] {\n  // Ensure we have at least one fund with at least 2 entries\n  if (navDataList.length === 0 || navDataList.some(fund => fund.length < 2)) {\n    return [];\n  }\n\n  const numFunds = navDataList.length;\n  \n  // Use provided allocations or default to equal split\n  const actualAllocations = allocations.length === numFunds \n    ? allocations \n    : Array(numFunds).fill(100 / numFunds);\n  \n  const filledNavs = navDataList.map(fund => {\n    let data = fund;\n    if (!areDatesContinuous(data)) {\n      data = fillMissingNavDates(data);\n    }\n    return data;\n  });\n\n  // Build date maps for O(1) lookups (same as SIP for performance)\n  const fundDateMaps = filledNavs.map(buildDateMap);\n\n  // Get a consolidated list of dates from the first fund (after filling)\n  const sorted = [...filledNavs[0]].sort((a, b) => a.date.getTime() - b.date.getTime());\n  const dateList = sorted.map(entry => entry.date);\n  const result: RollingXirrEntry[] = [];\n  const firstDate = dateList[0];\n  const months = 12 * years;\n\n  for (let i = 0; i < dateList.length; i++) {\n    const endDate = dateList[i];\n    const startDate = getNthPreviousMonthDate(endDate, months);\n    if (startDate < firstDate) continue;\n    \n    // Find start index in the first fund (all funds should be aligned after filling)\n    const startIdx = sorted.findIndex(entry =>\n      entry.date.getFullYear() === startDate.getFullYear() &&\n      entry.date.getMonth() === startDate.getMonth() &&\n      entry.date.getDate() === startDate.getDate()\n    );\n    if (startIdx === -1) continue;\n\n    // For each fund, calculate units bought at start and value at end\n    const fundUnits: number[] = [];\n    let valid = true;\n    \n    // Calculate units purchased for each fund based on allocations\n    for (let f = 0; f < numFunds; f++) {\n      const startEntry = fundDateMaps[f].get(toDateKey(startDate));\n      \n      if (!startEntry) { \n        valid = false; \n        break; \n      }\n      \n      const fundAllocation = (investmentAmount * actualAllocations[f]) / 100;\n      fundUnits[f] = fundAllocation / startEntry.nav;\n    }\n    \n    if (!valid) continue;\n    \n    // Calculate total portfolio value at end date\n    let totalValue = 0;\n    for (let f = 0; f < numFunds; f++) {\n      const endEntry = fundDateMaps[f].get(toDateKey(endDate));\n      \n      if (!endEntry) { \n        valid = false; \n        break; \n      }\n      \n      totalValue += fundUnits[f] * endEntry.nav;\n    }\n    \n    if (!valid) continue;\n\n    // Prepare transactions for XIRR\n    const xirrTransactions = [\n      { amount: -investmentAmount, when: startDate },\n      { amount: totalValue, when: endDate }\n    ];\n    \n    // Match the expected interface format\n    const transactions = [\n      { nav: investmentAmount, when: startDate },\n      { nav: totalValue, when: endDate }\n    ];\n    \n    let rate: number;\n    try {\n      rate = xirr(xirrTransactions);\n    } catch {\n      continue; // Skip if XIRR calculation fails\n    }\n    \n    // Calculate daily portfolio values for this specific period\n    const periodDailyValues = calculatePeriodDailyPortfolioValues(\n      fundDateMaps,\n      fundUnits,\n      sorted,\n      startDate,\n      endDate\n    );\n    \n    // Calculate volatility from daily values\n    const volatility = calculateVolatilityFromDailyValues(periodDailyValues);\n    \n    result.push({ \n      date: endDate, \n      xirr: rate, \n      transactions,\n      volatility: Math.round(volatility * 10000) / 10000 // Round to 4 decimal places\n    });\n  }\n  \n  return result;\n}\n\n/**\n * Calculate daily portfolio values for a specific rolling period\n * Similar to SIP pattern - each period calculates its own daily values independently\n * Uses date maps for O(1) lookups instead of O(n) array scans\n */\nfunction calculatePeriodDailyPortfolioValues(\n  fundDateMaps: Map<string, NavEntry>[],\n  fundUnits: number[],\n  sorted: NavEntry[],\n  startDate: Date,\n  endDate: Date\n): Array<{ date: Date; totalValue: number }> {\n  const numFunds = fundDateMaps.length;\n  const dailyValues: Array<{ date: Date; totalValue: number }> = [];\n  \n  // Filter dates within the period\n  const periodDates = sorted.filter(\n    entry => entry.date >= startDate && entry.date <= endDate\n  );\n  \n  // Calculate total portfolio value for each day in the period\n  for (const dateEntry of periodDates) {\n    let totalValue = 0;\n    let valid = true;\n\n    for (let f = 0; f < numFunds; f++) {\n      const navEntry = fundDateMaps[f].get(toDateKey(dateEntry.date));\n      \n      if (!navEntry) {\n        valid = false;\n        break;\n      }\n      \n      totalValue += fundUnits[f] * navEntry.nav;\n    }\n\n    if (valid && totalValue > 0) {\n      dailyValues.push({\n        date: dateEntry.date,\n        totalValue\n      });\n    }\n  }\n\n  return dailyValues;\n}\n\n/**\n * Calculate volatility from daily portfolio values\n * Simple version - no cash flow adjustments needed for lumpsum\n */\nfunction calculateVolatilityFromDailyValues(\n  dailyValues: Array<{ date: Date; totalValue: number }>\n): number {\n  if (dailyValues.length < 2) return 0;\n\n  // Calculate daily returns\n  const dailyReturns: number[] = [];\n  for (let i = 1; i < dailyValues.length; i++) {\n    const prevValue = dailyValues[i - 1].totalValue;\n    const currValue = dailyValues[i].totalValue;\n    \n    if (prevValue > 0) {\n      const dailyReturn = (currValue / prevValue) - 1;\n      dailyReturns.push(dailyReturn);\n    }\n  }\n\n  if (dailyReturns.length < 2) return 0;\n\n  // Calculate std dev\n  const mean = dailyReturns.reduce((sum, r) => sum + r, 0) / dailyReturns.length;\n  const variance = dailyReturns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / dailyReturns.length;\n  const stdDev = Math.sqrt(variance);\n\n  // Annualize (252 trading days)\n  return stdDev * Math.sqrt(252) * 100;\n} "],"names":["newtonRaphsonMethod","newtonRaphson","f","fp","x0","options","x1","y","yp","tol","maxIter","iter","yph","ymh","yp2h","ym2h","h","hr","verbose","eps","newton","require$$0","MILLIS_PER_DAY","DAYS_IN_YEAR","convert","data","investments","start","end","minAmount","maxAmount","total","deposits","datum","epochDays","investment","xirr","transactions","value","rate","sum","A","Y","derivative","guess","xirr_1","MILLISECONDS_PER_DAY","areDatesContinuous","navData","sorted","a","b","i","prev","getNthPreviousMonthDate","currentDate","months","date","d","fillMissingNavDates","filled","current","last","sameDay","toDateKey","buildDateMap","fund","entry","calculateLumpSumRollingXirr","navDataList","years","allocations","investmentAmount","numFunds","actualAllocations","filledNavs","fundDateMaps","dateList","result","firstDate","endDate","startDate","fundUnits","valid","startEntry","fundAllocation","totalValue","endEntry","xirrTransactions","periodDailyValues","calculatePeriodDailyPortfolioValues","volatility","calculateVolatilityFromDailyValues","dailyValues","periodDates","dateEntry","navEntry","dailyReturns","prevValue","currValue","dailyReturn","mean","r","variance"],"mappings":"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","x_google_ignoreList":[0,1]}