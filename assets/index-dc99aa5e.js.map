{"version":3,"file":"index-dc99aa5e.js","sources":["../src/utils/date/dateUtils.ts","../src/utils/data/fillMissingNavDates.ts","../src/utils/calculations/sipRollingXirr/core/helpers.ts","../src/utils/calculations/sipRollingXirr/transactions/buy.ts","../src/utils/calculations/sipRollingXirr/transactions/rebalance.ts","../src/utils/calculations/sipRollingXirr/transactions/nil.ts","../src/utils/calculations/sipRollingXirr/transactions/sell.ts","../src/utils/calculations/sipRollingXirr/core/transactionBuilder.ts","../node_modules/newton-raphson-method/index.js","../node_modules/xirr/xirr.js","../src/utils/calculations/sipRollingXirr/core/xirrCalculator.ts","../src/utils/calculations/sipRollingXirr/volatility/portfolioValue.ts","../src/utils/calculations/sipRollingXirr/volatility/volatilityCalculator.ts","../src/utils/calculations/sipRollingXirr/volatility/index.ts","../src/utils/calculations/sipRollingXirr/index.ts"],"sourcesContent":["// Date utility functions for NAV and lump sum rolling XIRR calculations\nimport { NavEntry } from '../../types/navData';\nimport { MILLISECONDS_PER_DAY } from '../../constants';\n\nexport function areDatesContinuous(navData: NavEntry[]): boolean {\n  if (navData.length < 2) return true;\n  const sorted = [...navData].sort((a, b) => a.date.getTime() - b.date.getTime());\n  for (let i = 1; i < sorted.length; i++) {\n    const prev = sorted[i - 1].date;\n    const curr = sorted[i].date;\n    const diff = (curr.getTime() - prev.getTime()) / MILLISECONDS_PER_DAY;\n    if (diff !== 1) return false;\n  }\n  return true;\n}\n\n// Get the date N months before a given date, handling month-end edge cases\nexport function getNthPreviousMonthDate(currentDate: Date, months: number): Date {\n  const date = new Date(currentDate);\n  const d = date.getDate();\n  date.setMonth(date.getMonth() - months);\n  // Handle month-end edge case (e.g., March 31 -> Feb 28/29)\n  if (date.getDate() < d) {\n    date.setDate(0); // Go to last day of previous month\n  }\n  return date;\n} ","import { NavEntry } from '../../types/navData';\n\nexport function fillMissingNavDates(navData: NavEntry[]): NavEntry[] {\n  if (navData.length === 0) return [];\n\n  // Sort ascending (oldest first)\n  const sorted = [...navData].sort((a, b) => a.date.getTime() - b.date.getTime());\n  const filled: NavEntry[] = [];\n  let i = 0;\n  let current = new Date(sorted[0].date);\n  const last = sorted[sorted.length - 1].date;\n\n  while (current <= last) {\n    if (i < sorted.length && sameDay(current, sorted[i].date)) {\n      filled.push({ date: new Date(current), nav: sorted[i].nav });\n      i++;\n    } else {\n      // Use the next available NAV (forward fill)\n      filled.push({ date: new Date(current), nav: sorted[i].nav });\n    }\n    current.setDate(current.getDate() + 1);\n  }\n  return filled;\n}\n\nfunction sameDay(a: Date, b: Date) {\n  return a.getFullYear() === b.getFullYear() &&\n    a.getMonth() === b.getMonth() &&\n    a.getDate() === b.getDate();\n} ","import { NavEntry } from '../../../../types/navData';\nimport { areDatesContinuous, getNthPreviousMonthDate } from '../../../date/dateUtils';\nimport { fillMissingNavDates } from '../../../data/fillMissingNavDates';\n\nexport function isValidInput(navDataList: NavEntry[][]): boolean {\n  return navDataList.length > 0 && !navDataList.some(f => f.length < 2);\n}\n\nexport function ensureContinuousDates(fund: NavEntry[]): NavEntry[] {\n  return areDatesContinuous(fund) ? fund : fillMissingNavDates(fund);\n}\n\nexport function buildDateMap(fund: NavEntry[]): Map<string, NavEntry> {\n  return new Map(fund.map(entry => [toDateKey(entry.date), entry]));\n}\n\nexport function getSortedDates(fund: NavEntry[]): Date[] {\n  return [...fund]\n    .sort((a, b) => a.date.getTime() - b.date.getTime())\n    .map(entry => entry.date);\n}\n\nexport function toDateKey(date: Date): string {\n  return date.toISOString().split('T')[0];\n}\n\n// ────────────── SIP Date Generation ────────────── //\n\nexport interface SipDatesResult {\n  dateSet: Set<string>;\n  earliestDate: Date | null;\n}\n\nexport function generateSipDates(\n  currentDate: Date,\n  months: number,\n  firstDate: Date\n): SipDatesResult {\n  const sipDates = new Set<string>();\n  let earliestSipDate: Date | null = null;\n\n  for (let m = months; m >= 1; m--) {\n    const sipDate = getNthPreviousMonthDate(currentDate, m);\n    if (sipDate < firstDate) {\n      return { dateSet: sipDates, earliestDate: null };\n    }\n\n    sipDates.add(toDateKey(sipDate));\n    if (!earliestSipDate || sipDate < earliestSipDate) {\n      earliestSipDate = sipDate;\n    }\n  }\n\n  return { dateSet: sipDates, earliestDate: earliestSipDate };\n}\n\n","import { NavEntry } from '../../../../types/navData';\nimport { Transaction } from '../types';\n\ninterface BuyTransactionsResult {\n  transactions: Transaction[];\n  portfolioValue: number;\n}\n\ninterface TransactionState {\n  cumulativeUnits: number[];\n  unitsPerFund: number[];\n}\n\n/**\n * Create buy transactions for a SIP date\n */\nexport function createBuyTransactions(\n  dateKey: string,\n  fundDateMaps: Map<string, NavEntry>[],\n  allocations: number[],\n  state: TransactionState\n): BuyTransactionsResult | null {\n  const totalInvestment = 100;\n  const transactions: Transaction[] = [];\n  let totalPortfolioValue = 0;\n  const fundValues: number[] = [];\n\n  for (let fundIdx = 0; fundIdx < fundDateMaps.length; fundIdx++) {\n    const entry = fundDateMaps[fundIdx].get(dateKey);\n    if (!entry) return null;\n\n    const investmentAmount = totalInvestment * (allocations[fundIdx] / 100);\n    const units = investmentAmount / entry.nav;\n\n    state.cumulativeUnits[fundIdx] += units;\n    state.unitsPerFund[fundIdx] += units;\n\n    const currentValue = state.cumulativeUnits[fundIdx] * entry.nav;\n    fundValues.push(currentValue);\n    totalPortfolioValue += currentValue;\n\n    transactions.push({\n      fundIdx,\n      nav: entry.nav,\n      when: entry.date,\n      units,\n      amount: -investmentAmount,\n      type: 'buy',\n      cumulativeUnits: state.cumulativeUnits[fundIdx],\n      currentValue,\n      allocationPercentage: 0,\n    });\n  }\n\n  transactions.forEach((tx, idx) => {\n    tx.allocationPercentage = totalPortfolioValue > 0 ? (fundValues[idx] / totalPortfolioValue) * 100 : 0;\n  });\n\n  return { transactions, portfolioValue: totalPortfolioValue };\n}\n\n","import { NavEntry } from '../../../../types/navData';\nimport { Transaction } from '../types';\n\ninterface TransactionState {\n  cumulativeUnits: number[];\n  unitsPerFund: number[];\n}\n\n/**\n * Create rebalance transactions if needed\n */\nexport function createRebalanceTransactions(\n  dateKey: string,\n  loopDate: Date,\n  fundDateMaps: Map<string, NavEntry>[],\n  allocations: number[],\n  rebalancingThreshold: number,\n  portfolioValue: number,\n  state: TransactionState\n): Transaction[] | null {\n  if (!isRebalancingNeeded(state.cumulativeUnits, fundDateMaps, dateKey, allocations, rebalancingThreshold, portfolioValue)) {\n    return [];\n  }\n\n  const transactions: Transaction[] = [];\n\n  for (let fundIdx = 0; fundIdx < fundDateMaps.length; fundIdx++) {\n    const entry = fundDateMaps[fundIdx].get(dateKey);\n    if (!entry) return null;\n\n    const currentValue = state.cumulativeUnits[fundIdx] * entry.nav;\n    const targetValue = portfolioValue * (allocations[fundIdx] / 100);\n    const rebalanceAmount = targetValue - currentValue;\n\n    if (Math.abs(rebalanceAmount) > 0.01) {\n      const rebalanceUnits = rebalanceAmount / entry.nav;\n\n      state.cumulativeUnits[fundIdx] += rebalanceUnits;\n      state.unitsPerFund[fundIdx] += rebalanceUnits;\n\n      transactions.push({\n        fundIdx,\n        when: new Date(loopDate),\n        nav: entry.nav,\n        units: rebalanceUnits,\n        amount: -rebalanceAmount,\n        type: 'rebalance',\n        cumulativeUnits: state.cumulativeUnits[fundIdx],\n        currentValue: state.cumulativeUnits[fundIdx] * entry.nav,\n        allocationPercentage: allocations[fundIdx],\n      });\n    }\n  }\n\n  return transactions;\n}\n\nfunction isRebalancingNeeded(\n  cumulativeUnits: number[],\n  fundDateMaps: Map<string, NavEntry>[],\n  dateKey: string,\n  allocations: number[],\n  threshold: number,\n  portfolioValue: number\n): boolean {\n  for (let fundIdx = 0; fundIdx < fundDateMaps.length; fundIdx++) {\n    const entry = fundDateMaps[fundIdx].get(dateKey);\n    if (!entry) continue;\n\n    const currentValue = cumulativeUnits[fundIdx] * entry.nav;\n    const currentAllocation = (currentValue / portfolioValue) * 100;\n    const targetAllocation = allocations[fundIdx];\n\n    if (Math.abs(currentAllocation - targetAllocation) > threshold) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n","import { NavEntry } from '../../../../types/navData';\nimport { Transaction } from '../types';\n\ninterface TransactionState {\n  cumulativeUnits: number[];\n}\n\n/**\n * Create nil transactions for non-SIP dates (showing current holdings)\n */\nexport function createNilTransactions(\n  dateKey: string,\n  fundDateMaps: Map<string, NavEntry>[],\n  state: Pick<TransactionState, 'cumulativeUnits'>\n): Transaction[] | null {\n  const transactions: Transaction[] = [];\n  let totalPortfolioValue = 0;\n\n  for (let fundIdx = 0; fundIdx < fundDateMaps.length; fundIdx++) {\n    const entry = fundDateMaps[fundIdx].get(dateKey);\n    if (!entry) return null;\n\n    const currentValue = state.cumulativeUnits[fundIdx] * entry.nav;\n    totalPortfolioValue += currentValue;\n\n    transactions.push({\n      fundIdx,\n      when: entry.date,\n      nav: entry.nav,\n      units: 0,\n      amount: 0,\n      type: 'nil',\n      cumulativeUnits: state.cumulativeUnits[fundIdx],\n      currentValue,\n      allocationPercentage: 0,\n    });\n  }\n\n  transactions.forEach(tx => {\n    tx.allocationPercentage = totalPortfolioValue > 0 ? (tx.currentValue / totalPortfolioValue) * 100 : 0;\n  });\n\n  return transactions;\n}\n\n","import { NavEntry } from '../../../../types/navData';\nimport { Transaction } from '../types';\nimport { toDateKey } from '../core/helpers';\n\n/**\n * Create final sell transactions at the end date\n */\nexport function createFinalSellTransactions(\n  currentDate: Date,\n  fundDateMaps: Map<string, NavEntry>[],\n  unitsPerFund: number[]\n): Transaction[] | null {\n  const dateKey = toDateKey(currentDate);\n  const sells: Transaction[] = [];\n\n  for (let fundIdx = 0; fundIdx < fundDateMaps.length; fundIdx++) {\n    const entry = fundDateMaps[fundIdx].get(dateKey);\n    if (!entry) return null;\n\n    const units = unitsPerFund[fundIdx];\n    const amount = units * entry.nav;\n\n    sells.push({\n      fundIdx,\n      nav: entry.nav,\n      when: entry.date,\n      units,\n      amount,\n      type: 'sell',\n      cumulativeUnits: units,\n      currentValue: units * entry.nav,\n    });\n  }\n\n  return sells;\n}\n\n","import { NavEntry } from '../../../../types/navData';\nimport { Transaction } from '../types';\nimport { toDateKey, generateSipDates } from './helpers';\nimport { createBuyTransactions } from '../transactions/buy';\nimport { createRebalanceTransactions } from '../transactions/rebalance';\nimport { createNilTransactions } from '../transactions/nil';\nimport { createFinalSellTransactions } from '../transactions/sell';\n\n/**\n * Calculate all transactions for a given date, including buy/rebalance/nil transactions\n * and the final sell transaction at the end date\n */\nexport function calculateTransactionsForDate(\n  currentDate: Date,\n  fundDateMaps: Map<string, NavEntry>[],\n  months: number,\n  firstDate: Date,\n  allocations: number[],\n  rebalancingEnabled: boolean,\n  rebalancingThreshold: number\n): Transaction[] | null {\n  const sipDates = generateSipDates(currentDate, months, firstDate);\n  if (!sipDates.earliestDate) {\n    return null;\n  }\n\n  const state = initializeState(fundDateMaps.length);\n  const transactions = buildDailyTransactions(\n    sipDates.earliestDate,\n    currentDate,\n    sipDates.dateSet,\n    fundDateMaps,\n    allocations,\n    rebalancingEnabled,\n    rebalancingThreshold,\n    state\n  );\n\n  if (!transactions) return null;\n\n  // Add final selling transactions at current date\n  const sellTransactions = createFinalSellTransactions(currentDate, fundDateMaps, state.unitsPerFund);\n  if (!sellTransactions) return null;\n\n  return [...transactions, ...sellTransactions];\n}\n\n// ────────────── Private Helpers ────────────── //\n\ninterface TransactionState {\n  unitsPerFund: number[];\n  cumulativeUnits: number[];\n}\n\nfunction initializeState(numFunds: number): TransactionState {\n  return {\n    unitsPerFund: new Array(numFunds).fill(0),\n    cumulativeUnits: new Array(numFunds).fill(0),\n  };\n}\n\nfunction buildDailyTransactions(\n  startDate: Date,\n  endDate: Date,\n  sipDates: Set<string>,\n  fundDateMaps: Map<string, NavEntry>[],\n  allocations: number[],\n  rebalancingEnabled: boolean,\n  rebalancingThreshold: number,\n  state: TransactionState\n): Transaction[] | null {\n  const transactions: Transaction[] = [];\n  const loopDate = new Date(startDate);\n\n  while (loopDate < endDate) {\n    const dateKey = toDateKey(loopDate);\n    const isSipDate = sipDates.has(dateKey);\n\n    const result = isSipDate\n      ? processSipDate(dateKey, loopDate, fundDateMaps, allocations, rebalancingEnabled, rebalancingThreshold, state)\n      : processNilDate(dateKey, fundDateMaps, state);\n\n    if (!result) return null;\n    transactions.push(...result);\n\n    loopDate.setDate(loopDate.getDate() + 1);\n  }\n\n  return transactions;\n}\n\nfunction processSipDate(\n  dateKey: string,\n  loopDate: Date,\n  fundDateMaps: Map<string, NavEntry>[],\n  allocations: number[],\n  rebalancingEnabled: boolean,\n  rebalancingThreshold: number,\n  state: TransactionState\n): Transaction[] | null {\n  const buyResult = createBuyTransactions(dateKey, fundDateMaps, allocations, state);\n  if (!buyResult) return null;\n\n  const rebalanceTransactions = rebalancingEnabled\n    ? createRebalanceTransactions(dateKey, loopDate, fundDateMaps, allocations, rebalancingThreshold, buyResult.portfolioValue, state)\n    : [];\n\n  if (rebalanceTransactions === null) return null;\n\n  return [...buyResult.transactions, ...rebalanceTransactions];\n}\n\nfunction processNilDate(\n  dateKey: string,\n  fundDateMaps: Map<string, NavEntry>[],\n  state: TransactionState\n): Transaction[] | null {\n  return createNilTransactions(dateKey, fundDateMaps, state);\n}\n\n","'use strict';\n\nmodule.exports = newtonRaphson;\n\nfunction newtonRaphson (f, fp, x0, options) {\n  var x1, y, yp, tol, maxIter, iter, yph, ymh, yp2h, ym2h, h, hr, verbose, eps;\n\n  // Iterpret variadic forms:\n  if (typeof fp !== 'function') {\n    options = x0;\n    x0 = fp;\n    fp = null;\n  }\n\n  options = options || {};\n  tol = options.tolerance === undefined ? 1e-7 : options.tolerance;\n  eps = options.epsilon === undefined ? 2.220446049250313e-16 : options.epsilon;\n  maxIter = options.maxIterations === undefined ? 20 : options.maxIterations;\n  h = options.h === undefined ? 1e-4 : options.h;\n  verbose = options.verbose === undefined ? false : options.verbose;\n  hr = 1 / h;\n\n  iter = 0;\n  while (iter++ < maxIter) {\n    // Compute the value of the function:\n    y = f(x0);\n\n    if (fp) {\n      yp = fp(x0);\n    } else {\n      // Needs numerical derivatives:\n      yph = f(x0 + h);\n      ymh = f(x0 - h);\n      yp2h = f(x0 + 2 * h);\n      ym2h = f(x0 - 2 * h);\n\n      yp = ((ym2h - yp2h) + 8 * (yph - ymh)) * hr / 12;\n    }\n\n    // Check for badly conditioned update (extremely small first deriv relative to function):\n    if (Math.abs(yp) <= eps * Math.abs(y)) {\n      if (verbose) {\n        console.log('Newton-Raphson: failed to converged due to nearly zero first derivative');\n      }\n      return false;\n    }\n\n    // Update the guess:\n    x1 = x0 - y / yp;\n\n    // Check for convergence:\n    if (Math.abs(x1 - x0) <= tol * Math.abs(x1)) {\n      if (verbose) {\n        console.log('Newton-Raphson: converged to x = ' + x1 + ' after ' + iter + ' iterations');\n      }\n      return x1;\n    }\n\n    // Transfer update to the new guess:\n    x0 = x1;\n  }\n\n  if (verbose) {\n    console.log('Newton-Raphson: Maximum iterations reached (' + maxIter + ')');\n  }\n\n  return false;\n}\n","'use strict';\n\nvar newton = require('newton-raphson-method');\n\nvar MILLIS_PER_DAY = 1000*60*60*24;\nvar DAYS_IN_YEAR = 365;\n\nfunction convert(data) {\n    if (!data || !data.length || !data.forEach || data.length < 2) {\n        throw new Error('Argument is not an array with length of 2 or more.');\n    }\n\n    var investments = [];\n    var start = Math.floor(data[0].when/MILLIS_PER_DAY);\n    var end = start;\n    var minAmount = Number.POSITIVE_INFINITY;\n    var maxAmount = Number.NEGATIVE_INFINITY;\n    var total = 0;\n    var deposits = 0;\n    data.forEach(function(datum) {\n        total += datum.amount;\n        if (datum.amount < 0) {\n            deposits += -datum.amount;\n        }\n        var epochDays = Math.floor(datum.when/MILLIS_PER_DAY);\n        start = Math.min(start, epochDays);\n        end = Math.max(end, epochDays);\n        minAmount = Math.min(minAmount, datum.amount);\n        maxAmount = Math.max(maxAmount, datum.amount);\n        investments.push({\n            amount: datum.amount,\n            epochDays: epochDays\n        });\n    });\n    if (start === end) {\n        throw new Error('Transactions must not all be on the same day.');\n    }\n    if (minAmount >= 0) {\n        throw new Error('Transactions must not all be nonnegative.');\n    }\n    if (maxAmount < 0) {\n        throw new Error('Transactions must not all be negative.');\n    }\n    investments.forEach(function(investment) {\n        // Number of years (including fraction) this item applies\n        investment.years = (end - investment.epochDays) / DAYS_IN_YEAR;\n    });\n    return {\n        total: total,\n        deposits: deposits,\n        days: end - start,\n        investments: investments,\n        maxAmount: maxAmount\n    };\n}\n\nfunction xirr(transactions, options) {\n    var data = convert(transactions);\n    if (data.maxAmount === 0) {\n        return -1;\n    }\n    var investments = data.investments;\n    var value = function(rate) {\n        return investments.reduce(function(sum, investment) {\n            // Make the vars more Math-y, makes the derivative easier to see\n            var A = investment.amount;\n            var Y = investment.years;\n            if (-1 < rate) {\n                return sum + A * Math.pow(1+rate, Y);\n            } else if (rate < -1) {\n                // Extend the function into the range where the rate is less\n                // than -100%.  Even though this does not make practical sense,\n                // it allows the algorithm to converge in the cases where the\n                // candidate values enter this range\n\n                // We cannot use the same formula as before, since the base of\n                // the exponent (1+rate) is negative, this yields imaginary\n                // values for fractional years.\n                // E.g. if rate=-1.5 and years=.5, it would be (-.5)^.5,\n                // i.e. the square root of negative one half.\n\n                // Ensure the values are always negative so there can never\n                // be a zero (as long as some amount is non-zero).\n                // This formula also ensures that the derivative is positive\n                // (when rate < -1) so that Newton's method is encouraged to \n                // move the candidate values towards the proper range\n\n                return sum - Math.abs(A) * Math.pow(-1-rate, Y);\n            } else if (Y === 0) {\n                return sum + A;  // Treat 0^0 as 1\n            } else {\n                return sum;\n            }\n        }, 0);\n    };\n    var derivative = function(rate) {\n        return investments.reduce(function(sum, investment) {\n            // Make the vars more Math-y, makes the derivative easier to see\n            var A = investment.amount;\n            var Y = investment.years;\n            if (Y === 0) {\n                return sum;\n            } else if (-1 < rate) {\n                return sum + A * Y * Math.pow(1+rate, Y-1);\n            } else if (rate < -1) {\n                return sum + Math.abs(A) * Y * Math.pow(-1-rate, Y-1);\n            } else {\n                return sum;\n            }\n        }, 0);\n    };\n    var guess = options ? options.guess : undefined;\n    if (guess && isNaN(guess)) {\n        throw new Error(\"option.guess must be a number.\");\n    }\n    if (!guess) {\n        guess = (data.total / data.deposits) / (data.days/DAYS_IN_YEAR);\n    }\n    var rate = newton(value, derivative, guess, options);\n    if (rate === false) {  // truthiness strikes again, !rate is true when rate is zero\n        throw new Error(\"Newton-Raphson algorithm failed to converge.\");\n    }\n    return rate;\n}\n\nmodule.exports = xirr;\n","import xirr from 'xirr';\nimport { Transaction } from '../types';\nimport { toDateKey } from './helpers';\n\n/**\n * Calculate XIRR from a list of transactions\n * \n * @param transactions - Array of transactions (buy, sell, rebalance, nil)\n * @param currentDate - Current date for error logging\n * @returns XIRR value or null if calculation fails\n */\nexport function calculateXirrFromTransactions(\n  transactions: Transaction[],\n  currentDate: Date\n): number | null {\n  const cashflows = aggregateCashflows(transactions);\n  return calculateXirr(cashflows, currentDate);\n}\n\n// ────────────── Private Helpers ────────────── //\n\nfunction aggregateCashflows(transactions: Transaction[]): Array<{ amount: number; when: Date }> {\n  const cashflowsMap = new Map<string, number>();\n\n  for (const tx of transactions) {\n    if (tx.type === 'nil') continue; // Skip nil transactions (amount: 0, just overhead)\n\n    const dateKey = toDateKey(tx.when);\n    const currentAmount = cashflowsMap.get(dateKey) || 0;\n    cashflowsMap.set(dateKey, currentAmount + tx.amount);\n  }\n\n  const cashflows = Array.from(cashflowsMap.entries()).map(([dateStr, amount]) => ({\n    amount,\n    when: new Date(dateStr),\n  }));\n\n  cashflows.sort((a, b) => a.when.getTime() - b.when.getTime());\n\n  return cashflows;\n}\n\nfunction calculateXirr(cashflows: Array<{ amount: number; when: Date }>, currentDate: Date): number | null {\n  try {\n    return xirr(cashflows);\n  } catch (error) {\n    console.warn(`XIRR calculation failed for date ${currentDate.toISOString()}:`, error);\n    return null;\n  }\n}\n\n","import { Transaction } from '../types';\n\nexport interface DailyPortfolioValue {\n  date: Date;\n  totalValue: number;\n  cashFlow: number; // Net cash flow on this day (negative for buy, positive for sell)\n}\n\n/**\n * Calculate daily portfolio values from transactions\n * Uses total portfolio value (sum of currentValue across all funds)\n * Includes nil and buy transactions to capture market movements on buy days\n * Tracks cash flows for accurate return calculation\n * \n * @param transactions - All transactions\n */\nexport function calculateDailyPortfolioValue(\n  transactions: Transaction[]\n): DailyPortfolioValue[] {\n  // Include nil and buy transactions (exclude sell and rebalance)\n  const relevantTransactions = transactions.filter(\n    tx => tx.type === 'nil' || tx.type === 'buy'\n  );\n\n  if (relevantTransactions.length === 0) {\n    return [];\n  }\n\n  // Group transactions by date\n  const transactionsByDate = groupTransactionsByDate(relevantTransactions);\n\n  // Calculate total value and cash flow for each date\n  const dailyValues: DailyPortfolioValue[] = [];\n\n  for (const [dateKey, txs] of transactionsByDate.entries()) {\n    const totalValue = calculateTotalValue(txs);\n    const cashFlow = calculateCashFlow(txs);\n    \n    if (totalValue > 0) {\n      dailyValues.push({\n        date: txs[0].when,\n        totalValue,\n        cashFlow\n      });\n    }\n  }\n\n  // Sort by date\n  dailyValues.sort((a, b) => a.date.getTime() - b.date.getTime());\n\n  return dailyValues;\n}\n\n/**\n * Group transactions by date (using date string as key)\n */\nfunction groupTransactionsByDate(\n  transactions: Transaction[]\n): Map<string, Transaction[]> {\n  const grouped = new Map<string, Transaction[]>();\n\n  for (const tx of transactions) {\n    const dateKey = toDateKey(tx.when);\n    if (!grouped.has(dateKey)) {\n      grouped.set(dateKey, []);\n    }\n    grouped.get(dateKey)!.push(tx);\n  }\n\n  return grouped;\n}\n\n/**\n * Calculate total portfolio value for a set of transactions on the same date\n * Total Value = Σ(currentValue) - Sum of all fund positions' current values\n */\nfunction calculateTotalValue(transactions: Transaction[]): number {\n  if (transactions.length === 0) {\n    return 0;\n  }\n\n  // Calculate total portfolio value by summing currentValue of all funds\n  let totalValue = 0;\n  for (const tx of transactions) {\n    totalValue += tx.currentValue;\n  }\n\n  return totalValue;\n}\n\n/**\n * Calculate net cash flow for a set of transactions on the same date\n * Cash Flow = Σ(amount) where negative = money invested, positive = money withdrawn\n */\nfunction calculateCashFlow(transactions: Transaction[]): number {\n  let netCashFlow = 0;\n  for (const tx of transactions) {\n    // amount is negative for buy (money out), positive for sell (money in)\n    netCashFlow += tx.amount;\n  }\n  return netCashFlow;\n}\n\n/**\n * Convert date to string key (YYYY-MM-DD)\n */\nfunction toDateKey(date: Date): string {\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, '0');\n  const day = String(date.getDate()).padStart(2, '0');\n  return `${year}-${month}-${day}`;\n}\n\n","import { DailyPortfolioValue } from './portfolioValue';\n\nconst TRADING_DAYS_PER_YEAR = 252;\n\n/**\n * Calculate portfolio volatility from daily portfolio values\n * Returns annualized volatility as a percentage\n * \n * Automatically excludes forward-filled weekends/holidays (where value didn't change)\n * and adjusts annualization based on actual trading days in the data\n */\nexport function calculateVolatility(\n  dailyValues: DailyPortfolioValue[]\n): number {\n  // Need at least 2 data points to calculate volatility\n  if (dailyValues.length < 2) {\n    return 0;\n  }\n\n  // Calculate daily returns (excludes forward-filled non-trading days)\n  const dailyReturns = calculateDailyReturns(dailyValues);\n\n  // Need at least 2 returns to calculate volatility\n  if (dailyReturns.length < 2) {\n    return 0;\n  }\n\n  // Calculate mean return\n  const meanReturn = dailyReturns.reduce((sum, r) => sum + r, 0) / dailyReturns.length;\n\n  // Calculate variance\n  const variance = dailyReturns.reduce((sum, r) => {\n    const diff = r - meanReturn;\n    return sum + (diff * diff);\n  }, 0) / dailyReturns.length;\n\n  // Calculate standard deviation (daily volatility)\n  const dailyVolatility = Math.sqrt(variance);\n\n  // Calculate trading days per year based on actual data\n  // If we have 365 days but only 252 returns (69% ratio), annualize accordingly\n  const totalDays = dailyValues.length - 1; // Subtract 1 since we calculate returns between days\n  const tradingDays = dailyReturns.length;\n  const tradingDaysPerYear = totalDays > 0 \n    ? Math.round((tradingDays / totalDays) * 365)\n    : TRADING_DAYS_PER_YEAR; // Default to 252 if calculation fails\n\n  // Annualize volatility using calculated trading days\n  const annualizedVolatility = dailyVolatility * Math.sqrt(tradingDaysPerYear);\n\n  const volatilityPercent = (annualizedVolatility * 100) || 0;\n\n  return volatilityPercent;\n}\n\n/**\n * Calculate daily returns from portfolio values\n * Daily Return = (Today's Value - Yesterday's Value + Cash Flow) / Yesterday's Value\n * \n * Adjusts for cash flows to get true market returns:\n * - On buy days: valueChange + (-100) removes the 100 investment from the increase\n * - On nil days: valueChange + 0 = no adjustment needed\n * - This isolates the market movement from cash flow effects\n * \n * Skips forward-filled days (weekends/holidays) where:\n * - Portfolio value didn't change AND\n * - No cash flow occurred (no actual transaction)\n * This prevents artificially low volatility from zero returns on non-trading days\n */\nfunction calculateDailyReturns(dailyValues: DailyPortfolioValue[]): number[] {\n  const returns: number[] = [];\n\n  // Calculate returns from consecutive days (array is already sorted and continuous)\n  for (let i = 1; i < dailyValues.length; i++) {\n    const previousEntry = dailyValues[i - 1];\n    const currentEntry = dailyValues[i];\n\n    if (previousEntry.totalValue > 0) {\n      const valueChange = currentEntry.totalValue - previousEntry.totalValue;\n      \n      // Skip forward-filled days (weekends/holidays) where value didn't change and no cash flow\n      // This prevents artificially low volatility from zero returns on non-trading days\n      if (valueChange === 0 && currentEntry.cashFlow === 0) {\n        continue; // Skip this day - it's a forward-filled non-trading day\n      }\n      \n      // Adjust for cash flow to get true market return\n      // currentEntry.cashFlow is negative for buy (money out)\n      // We ADD cashFlow to remove investment effect from value change\n      const marketReturn = (valueChange + currentEntry.cashFlow) / previousEntry.totalValue;\n      \n      returns.push(marketReturn);\n    }\n  }\n\n  return returns;\n}\n\n","import { Transaction } from '../types';\nimport { calculateDailyPortfolioValue } from './portfolioValue';\nimport { calculateVolatility } from './volatilityCalculator';\n\nexport type { DailyPortfolioValue } from './portfolioValue';\n\n/**\n * Calculate portfolio volatility for a set of transactions\n * \n * @param transactions - All transactions from SIP start to current date\n * @returns Annualized volatility percentage (0 if insufficient data)\n */\nexport function calculateVolatilityForEntry(\n  transactions: Transaction[]\n): number {\n  // Calculate daily portfolio values using actual drifting allocations\n  const dailyValues = calculateDailyPortfolioValue(transactions);\n\n  // Calculate volatility from portfolio values\n  return calculateVolatility(dailyValues);\n}\n\n","import { NavEntry } from '../../../types/navData';\nimport { SipRollingXirrEntry } from './types';\nimport { isValidInput, ensureContinuousDates, buildDateMap, getSortedDates } from './core/helpers';\nimport { calculateTransactionsForDate } from './core/transactionBuilder';\nimport { calculateXirrFromTransactions } from './core/xirrCalculator';\nimport { calculateVolatilityForEntry } from './volatility';\n\n// Re-export types for backward compatibility\nexport type { SipRollingXirrEntry, Transaction } from './types';\n\n/**\n * Calculate SIP Rolling XIRR for given NAV data\n * \n * @param navDataList - Array of NAV data for each fund\n * @param years - Rolling period in years (default: 1)\n * @param allocations - Target allocation percentages for each fund\n * @param rebalancingEnabled - Whether to enable portfolio rebalancing (default: false)\n * @param rebalancingThreshold - Threshold percentage for triggering rebalancing (default: 5)\n * @param includeNilTransactions - Whether to include nil transactions in result (default: false, set true for tests)\n * @returns Array of SIP Rolling XIRR entries for each date\n */\nexport function calculateSipRollingXirr(\n  navDataList: NavEntry[][],\n  years: number = 1,\n  allocations: number[],\n  rebalancingEnabled: boolean = false,\n  rebalancingThreshold: number = 5,\n  includeNilTransactions: boolean = false\n): SipRollingXirrEntry[] {\n  // Validate input\n  if (!isValidInput(navDataList)) return [];\n\n  // Prepare data\n  const months = years * 12;\n  const filledNavs = navDataList.map(ensureContinuousDates);\n  const fundDateMaps = filledNavs.map(buildDateMap);\n  const baseDates = getSortedDates(filledNavs[0]);\n  const firstDate = baseDates[0];\n\n  // Calculate XIRR for each date\n  return baseDates.flatMap(date =>\n    computeSipXirrForDate(\n      date,\n      fundDateMaps,\n      months,\n      firstDate,\n      allocations,\n      rebalancingEnabled,\n      rebalancingThreshold,\n      includeNilTransactions\n    )\n  );\n}\n\n/**\n * Compute SIP XIRR for a single date\n * This is the orchestration function that coordinates transaction building and XIRR calculation\n */\nfunction computeSipXirrForDate(\n  currentDate: Date,\n  fundDateMaps: Map<string, NavEntry>[],\n  months: number,\n  firstDate: Date,\n  allocations: number[],\n  rebalancingEnabled: boolean,\n  rebalancingThreshold: number,\n  includeNilTransactions: boolean\n): SipRollingXirrEntry[] {\n  // Build all transactions (buy, sell, rebalance, nil)\n  const allTransactions = calculateTransactionsForDate(\n    currentDate,\n    fundDateMaps,\n    months,\n    firstDate,\n    allocations,\n    rebalancingEnabled,\n    rebalancingThreshold\n  );\n\n  if (!allTransactions) return [];\n\n  // Calculate XIRR from transactions\n  const xirrValue = calculateXirrFromTransactions(allTransactions, currentDate);\n  if (xirrValue === null) return [];\n\n  // Calculate volatility from all transactions (includes nil for accurate daily tracking)\n  const volatility = calculateVolatilityForEntry(allTransactions);\n\n  // Filter nil transactions if not needed (for memory efficiency)\n  const transactionsToReturn = includeNilTransactions\n    ? allTransactions\n    : allTransactions.filter(tx => tx.type !== 'nil');\n\n  return [{\n    date: currentDate,\n    xirr: xirrValue,\n    transactions: transactionsToReturn,\n    volatility\n  }];\n}\n"],"names":["areDatesContinuous","navData","sorted","a","b","i","prev","getNthPreviousMonthDate","currentDate","months","date","d","fillMissingNavDates","filled","current","last","sameDay","isValidInput","navDataList","f","ensureContinuousDates","fund","buildDateMap","entry","toDateKey","getSortedDates","generateSipDates","firstDate","sipDates","earliestSipDate","m","sipDate","createBuyTransactions","dateKey","fundDateMaps","allocations","state","transactions","totalPortfolioValue","fundValues","fundIdx","investmentAmount","units","currentValue","tx","idx","createRebalanceTransactions","loopDate","rebalancingThreshold","portfolioValue","isRebalancingNeeded","rebalanceAmount","rebalanceUnits","cumulativeUnits","threshold","currentAllocation","targetAllocation","createNilTransactions","createFinalSellTransactions","unitsPerFund","sells","amount","calculateTransactionsForDate","rebalancingEnabled","initializeState","buildDailyTransactions","sellTransactions","numFunds","startDate","endDate","result","processSipDate","processNilDate","buyResult","rebalanceTransactions","newtonRaphsonMethod","newtonRaphson","fp","x0","options","x1","y","yp","tol","maxIter","iter","yph","ymh","yp2h","ym2h","h","hr","verbose","eps","newton","require$$0","MILLIS_PER_DAY","DAYS_IN_YEAR","convert","data","investments","start","end","minAmount","maxAmount","total","deposits","datum","epochDays","investment","xirr","value","rate","sum","A","Y","derivative","guess","xirr_1","calculateXirrFromTransactions","cashflows","aggregateCashflows","calculateXirr","cashflowsMap","currentAmount","dateStr","error","calculateDailyPortfolioValue","relevantTransactions","transactionsByDate","groupTransactionsByDate","dailyValues","txs","totalValue","calculateTotalValue","cashFlow","calculateCashFlow","grouped","netCashFlow","year","month","day","TRADING_DAYS_PER_YEAR","calculateVolatility","dailyReturns","calculateDailyReturns","meanReturn","r","variance","diff","dailyVolatility","totalDays","tradingDays","tradingDaysPerYear","returns","previousEntry","currentEntry","valueChange","marketReturn","calculateVolatilityForEntry","calculateSipRollingXirr","years","includeNilTransactions","filledNavs","baseDates","computeSipXirrForDate","allTransactions","xirrValue","volatility","transactionsToReturn"],"mappings":"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","x_google_ignoreList":[8,9]}