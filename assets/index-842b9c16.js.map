{"version":3,"file":"index-842b9c16.js","sources":["../node_modules/newton-raphson-method/index.js","../node_modules/xirr/xirr.js","../src/constants/index.ts","../src/utils/date/dateUtils.ts","../src/utils/data/fillMissingNavDates.ts","../src/utils/calculations/lumpSumRollingXirr/volatility/volatilityCalculator.ts","../src/utils/calculations/lumpSumRollingXirr/volatility/index.ts","../src/utils/calculations/lumpSumRollingXirr/index.ts"],"sourcesContent":["'use strict';\n\nmodule.exports = newtonRaphson;\n\nfunction newtonRaphson (f, fp, x0, options) {\n  var x1, y, yp, tol, maxIter, iter, yph, ymh, yp2h, ym2h, h, hr, verbose, eps;\n\n  // Iterpret variadic forms:\n  if (typeof fp !== 'function') {\n    options = x0;\n    x0 = fp;\n    fp = null;\n  }\n\n  options = options || {};\n  tol = options.tolerance === undefined ? 1e-7 : options.tolerance;\n  eps = options.epsilon === undefined ? 2.220446049250313e-16 : options.epsilon;\n  maxIter = options.maxIterations === undefined ? 20 : options.maxIterations;\n  h = options.h === undefined ? 1e-4 : options.h;\n  verbose = options.verbose === undefined ? false : options.verbose;\n  hr = 1 / h;\n\n  iter = 0;\n  while (iter++ < maxIter) {\n    // Compute the value of the function:\n    y = f(x0);\n\n    if (fp) {\n      yp = fp(x0);\n    } else {\n      // Needs numerical derivatives:\n      yph = f(x0 + h);\n      ymh = f(x0 - h);\n      yp2h = f(x0 + 2 * h);\n      ym2h = f(x0 - 2 * h);\n\n      yp = ((ym2h - yp2h) + 8 * (yph - ymh)) * hr / 12;\n    }\n\n    // Check for badly conditioned update (extremely small first deriv relative to function):\n    if (Math.abs(yp) <= eps * Math.abs(y)) {\n      if (verbose) {\n        console.log('Newton-Raphson: failed to converged due to nearly zero first derivative');\n      }\n      return false;\n    }\n\n    // Update the guess:\n    x1 = x0 - y / yp;\n\n    // Check for convergence:\n    if (Math.abs(x1 - x0) <= tol * Math.abs(x1)) {\n      if (verbose) {\n        console.log('Newton-Raphson: converged to x = ' + x1 + ' after ' + iter + ' iterations');\n      }\n      return x1;\n    }\n\n    // Transfer update to the new guess:\n    x0 = x1;\n  }\n\n  if (verbose) {\n    console.log('Newton-Raphson: Maximum iterations reached (' + maxIter + ')');\n  }\n\n  return false;\n}\n","'use strict';\n\nvar newton = require('newton-raphson-method');\n\nvar MILLIS_PER_DAY = 1000*60*60*24;\nvar DAYS_IN_YEAR = 365;\n\nfunction convert(data) {\n    if (!data || !data.length || !data.forEach || data.length < 2) {\n        throw new Error('Argument is not an array with length of 2 or more.');\n    }\n\n    var investments = [];\n    var start = Math.floor(data[0].when/MILLIS_PER_DAY);\n    var end = start;\n    var minAmount = Number.POSITIVE_INFINITY;\n    var maxAmount = Number.NEGATIVE_INFINITY;\n    var total = 0;\n    var deposits = 0;\n    data.forEach(function(datum) {\n        total += datum.amount;\n        if (datum.amount < 0) {\n            deposits += -datum.amount;\n        }\n        var epochDays = Math.floor(datum.when/MILLIS_PER_DAY);\n        start = Math.min(start, epochDays);\n        end = Math.max(end, epochDays);\n        minAmount = Math.min(minAmount, datum.amount);\n        maxAmount = Math.max(maxAmount, datum.amount);\n        investments.push({\n            amount: datum.amount,\n            epochDays: epochDays\n        });\n    });\n    if (start === end) {\n        throw new Error('Transactions must not all be on the same day.');\n    }\n    if (minAmount >= 0) {\n        throw new Error('Transactions must not all be nonnegative.');\n    }\n    if (maxAmount < 0) {\n        throw new Error('Transactions must not all be negative.');\n    }\n    investments.forEach(function(investment) {\n        // Number of years (including fraction) this item applies\n        investment.years = (end - investment.epochDays) / DAYS_IN_YEAR;\n    });\n    return {\n        total: total,\n        deposits: deposits,\n        days: end - start,\n        investments: investments,\n        maxAmount: maxAmount\n    };\n}\n\nfunction xirr(transactions, options) {\n    var data = convert(transactions);\n    if (data.maxAmount === 0) {\n        return -1;\n    }\n    var investments = data.investments;\n    var value = function(rate) {\n        return investments.reduce(function(sum, investment) {\n            // Make the vars more Math-y, makes the derivative easier to see\n            var A = investment.amount;\n            var Y = investment.years;\n            if (-1 < rate) {\n                return sum + A * Math.pow(1+rate, Y);\n            } else if (rate < -1) {\n                // Extend the function into the range where the rate is less\n                // than -100%.  Even though this does not make practical sense,\n                // it allows the algorithm to converge in the cases where the\n                // candidate values enter this range\n\n                // We cannot use the same formula as before, since the base of\n                // the exponent (1+rate) is negative, this yields imaginary\n                // values for fractional years.\n                // E.g. if rate=-1.5 and years=.5, it would be (-.5)^.5,\n                // i.e. the square root of negative one half.\n\n                // Ensure the values are always negative so there can never\n                // be a zero (as long as some amount is non-zero).\n                // This formula also ensures that the derivative is positive\n                // (when rate < -1) so that Newton's method is encouraged to \n                // move the candidate values towards the proper range\n\n                return sum - Math.abs(A) * Math.pow(-1-rate, Y);\n            } else if (Y === 0) {\n                return sum + A;  // Treat 0^0 as 1\n            } else {\n                return sum;\n            }\n        }, 0);\n    };\n    var derivative = function(rate) {\n        return investments.reduce(function(sum, investment) {\n            // Make the vars more Math-y, makes the derivative easier to see\n            var A = investment.amount;\n            var Y = investment.years;\n            if (Y === 0) {\n                return sum;\n            } else if (-1 < rate) {\n                return sum + A * Y * Math.pow(1+rate, Y-1);\n            } else if (rate < -1) {\n                return sum + Math.abs(A) * Y * Math.pow(-1-rate, Y-1);\n            } else {\n                return sum;\n            }\n        }, 0);\n    };\n    var guess = options ? options.guess : undefined;\n    if (guess && isNaN(guess)) {\n        throw new Error(\"option.guess must be a number.\");\n    }\n    if (!guess) {\n        guess = (data.total / data.deposits) / (data.days/DAYS_IN_YEAR);\n    }\n    var rate = newton(value, derivative, guess, options);\n    if (rate === false) {  // truthiness strikes again, !rate is true when rate is zero\n        throw new Error(\"Newton-Raphson algorithm failed to converge.\");\n    }\n    return rate;\n}\n\nmodule.exports = xirr;\n","// Application constants\nexport const DEFAULT_SCHEME_CODE = 120716;\nexport const DEFAULT_REBALANCING_THRESHOLD = 5;\n\n// API Configuration\nexport const API_ENDPOINTS = {\n  MFAPI_BASE: 'https://api.mfapi.in',\n  YAHOO_FINANCE_PROXY: 'https://api.allorigins.win/get?url=',\n  INDEX_DATA_BASE: 'https://raw.githubusercontent.com/asrajavel/mf-index-data/main'\n} as const;\n\n// UI Configuration\nexport const COLORS = [\n  '#007bff', '#28a745', '#ff9800', '#e91e63', \n  '#9c27b0', '#00bcd4', '#795548', '#607d8b'\n];\n\n// Validation\nexport const ALLOCATION_TOTAL = 100;\nexport const MIN_ALLOCATION = 0;\nexport const MAX_ALLOCATION = 100;\n\n// Date calculations\nexport const MILLISECONDS_PER_DAY = 1000 * 60 * 60 * 24;\nexport const MONTHS_PER_YEAR = 12;\n\n// Chart Styling Configuration\nexport const CHART_STYLES = {\n  title: {\n    fontSize: '18px',\n    fontWeight: '600',\n    color: '#1f2937',\n    fontFamily: 'system-ui, -apple-system, sans-serif'\n  },\n  axisTitle: {\n    fontSize: '14px',\n    fontWeight: '500',\n    color: '#6b7280',\n    fontFamily: 'system-ui, -apple-system, sans-serif'\n  },\n  axisLabels: {\n    fontSize: '12px',\n    color: '#6b7280',\n    fontFamily: 'system-ui, -apple-system, sans-serif'\n  },\n  legend: {\n    fontSize: '13px',\n    fontWeight: '500',\n    color: '#374151'\n  },\n  tooltip: {\n    fontSize: '12px',\n    color: '#ffffff'\n  },\n  colors: {\n    gridLine: '#f3f4f6',\n    line: '#e5e7eb',\n    tick: '#e5e7eb',\n    background: '#ffffff',\n    tooltipBackground: '#1f2937'\n  }\n} as const;\n","// Date utility functions for NAV and lump sum rolling XIRR calculations\nimport { NavEntry } from '../../types/navData';\nimport { MILLISECONDS_PER_DAY } from '../../constants';\n\nexport function areDatesContinuous(navData: NavEntry[]): boolean {\n  if (navData.length < 2) return true;\n  const sorted = [...navData].sort((a, b) => a.date.getTime() - b.date.getTime());\n  for (let i = 1; i < sorted.length; i++) {\n    const prev = sorted[i - 1].date;\n    const curr = sorted[i].date;\n    const diff = (curr.getTime() - prev.getTime()) / MILLISECONDS_PER_DAY;\n    if (diff !== 1) return false;\n  }\n  return true;\n}\n\n// Get the date N months before a given date, handling month-end edge cases\nexport function getNthPreviousMonthDate(currentDate: Date, months: number): Date {\n  const date = new Date(currentDate);\n  const d = date.getDate();\n  date.setMonth(date.getMonth() - months);\n  // Handle month-end edge case (e.g., March 31 -> Feb 28/29)\n  if (date.getDate() < d) {\n    date.setDate(0); // Go to last day of previous month\n  }\n  return date;\n} ","import { NavEntry } from '../../types/navData';\n\nexport function fillMissingNavDates(navData: NavEntry[]): NavEntry[] {\n  if (navData.length === 0) return [];\n\n  // Sort ascending (oldest first)\n  const sorted = [...navData].sort((a, b) => a.date.getTime() - b.date.getTime());\n  const filled: NavEntry[] = [];\n  let i = 0;\n  let current = new Date(sorted[0].date);\n  const last = sorted[sorted.length - 1].date;\n\n  while (current <= last) {\n    if (i < sorted.length && sameDay(current, sorted[i].date)) {\n      filled.push({ date: new Date(current), nav: sorted[i].nav });\n      i++;\n    } else {\n      // Use the next available NAV (forward fill)\n      filled.push({ date: new Date(current), nav: sorted[i].nav });\n    }\n    current.setDate(current.getDate() + 1);\n  }\n  return filled;\n}\n\nfunction sameDay(a: Date, b: Date) {\n  return a.getFullYear() === b.getFullYear() &&\n    a.getMonth() === b.getMonth() &&\n    a.getDate() === b.getDate();\n} ","const TRADING_DAYS_PER_YEAR = 252;\n\nexport interface DailyPortfolioValue {\n  date: Date;\n  totalValue: number;\n}\n\n/**\n * Calculate portfolio volatility from daily portfolio values\n * Returns annualized volatility as a percentage\n * \n * Lumpsum version is simpler than SIP since there are no intermediate cash flows\n * to adjust for - just a single investment at start\n */\nexport function calculateVolatility(\n  dailyValues: DailyPortfolioValue[]\n): number {\n  // Need at least 2 data points to calculate volatility\n  if (dailyValues.length < 2) {\n    return 0;\n  }\n\n  // Calculate daily returns\n  const dailyReturns = calculateDailyReturns(dailyValues);\n\n  // Need at least 2 returns to calculate volatility\n  if (dailyReturns.length < 2) {\n    return 0;\n  }\n\n  // Calculate mean return\n  const meanReturn = dailyReturns.reduce((sum, r) => sum + r, 0) / dailyReturns.length;\n\n  // Calculate variance\n  const variance = dailyReturns.reduce((sum, r) => {\n    const diff = r - meanReturn;\n    return sum + (diff * diff);\n  }, 0) / dailyReturns.length;\n\n  // Calculate standard deviation (daily volatility)\n  const dailyVolatility = Math.sqrt(variance);\n\n  // Annualize volatility using standard 252 trading days\n  const annualizedVolatility = dailyVolatility * Math.sqrt(TRADING_DAYS_PER_YEAR);\n\n  const volatilityPercent = (annualizedVolatility * 100) || 0;\n\n  return volatilityPercent;\n}\n\n/**\n * Calculate daily returns from portfolio values\n * Daily Return = (Today's Value / Yesterday's Value) - 1\n * \n * Simpler than SIP since lumpsum has no intermediate cash flows\n * Just pure market returns on the invested capital\n */\nfunction calculateDailyReturns(dailyValues: DailyPortfolioValue[]): number[] {\n  const returns: number[] = [];\n\n  for (let i = 1; i < dailyValues.length; i++) {\n    const previousValue = dailyValues[i - 1].totalValue;\n    const currentValue = dailyValues[i].totalValue;\n\n    if (previousValue > 0) {\n      const dailyReturn = (currentValue / previousValue) - 1;\n      returns.push(dailyReturn);\n    }\n  }\n\n  return returns;\n}\n","import { Transaction } from '../../sipRollingXirr/types';\nimport { calculateVolatility, DailyPortfolioValue } from './volatilityCalculator';\n\nexport type { DailyPortfolioValue } from './volatilityCalculator';\n\n/**\n * Calculate portfolio volatility for a set of lumpsum transactions\n * \n * @param transactions - All transactions from investment start to current date\n * @returns Annualized volatility percentage (0 if insufficient data)\n */\nexport function calculateVolatilityForEntry(\n  transactions: Transaction[]\n): number {\n  // Extract daily portfolio values from transactions\n  const dailyValues = extractDailyPortfolioValues(transactions);\n\n  // Calculate volatility from portfolio values\n  return calculateVolatility(dailyValues);\n}\n\n/**\n * Extract daily portfolio values from transactions\n * Groups transactions by date and sums current values\n */\nfunction extractDailyPortfolioValues(\n  transactions: Transaction[]\n): DailyPortfolioValue[] {\n  // Group by date to get daily portfolio values\n  const dailyValuesMap = new Map<string, number>();\n  \n  for (const tx of transactions) {\n    const dateKey = tx.when.toISOString().split('T')[0];\n    const existing = dailyValuesMap.get(dateKey) || 0;\n    dailyValuesMap.set(dateKey, existing + tx.currentValue);\n  }\n\n  // Convert to array and sort by date\n  return Array.from(dailyValuesMap.entries())\n    .sort((a, b) => a[0].localeCompare(b[0]))\n    .map(([dateStr, totalValue]) => ({\n      date: new Date(dateStr),\n      totalValue\n    }));\n}\n","import xirr from 'xirr';\nimport { NavEntry } from '../../../types/navData';\nimport { areDatesContinuous, getNthPreviousMonthDate } from '../../date/dateUtils';\nimport { fillMissingNavDates } from '../../data/fillMissingNavDates';\nimport { calculateVolatilityForEntry } from './volatility';\nimport { Transaction } from '../sipRollingXirr/types';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface RollingXirrEntry {\n  date: Date;\n  xirr: number;\n  transactions: Transaction[];\n  volatility?: number;\n}\n\n// Re-export Transaction for convenience\nexport type { Transaction } from '../sipRollingXirr/types';\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\nfunction toDateKey(date: Date): string {\n  return date.toISOString().split('T')[0];\n}\n\nfunction buildDateMap(fund: NavEntry[]): Map<string, NavEntry> {\n  return new Map(fund.map(entry => [toDateKey(entry.date), entry]));\n}\n\nfunction ensureContinuousDates(fund: NavEntry[]): NavEntry[] {\n  return areDatesContinuous(fund) ? fund : fillMissingNavDates(fund);\n}\n\nfunction isValidInput(navDataList: NavEntry[][]): boolean {\n  return navDataList.length > 0 && navDataList.every(fund => fund.length >= 2);\n}\n\nfunction getSortedDates(fund: NavEntry[]): NavEntry[] {\n  return [...fund].sort((a, b) => a.date.getTime() - b.date.getTime());\n}\n\n// ============================================================================\n// MAIN CALCULATION FUNCTION\n// ============================================================================\n\n/**\n * Calculate Lumpsum Rolling XIRR for given NAV data\n * \n * @param navDataList - Array of NAV data for each fund\n * @param years - Rolling period in years (default: 1)\n * @param allocations - Target allocation percentages for each fund (default: equal split)\n * @param investmentAmount - Total investment amount (default: 100)\n * @param includeNilTransactions - Whether to include nil transactions in result (default: false)\n * @returns Array of Lumpsum Rolling XIRR entries for each date\n */\nexport function calculateLumpSumRollingXirr(\n  navDataList: NavEntry[][],\n  years: number = 1,\n  allocations: number[] = [],\n  investmentAmount: number = 100,\n  includeNilTransactions: boolean = false\n): RollingXirrEntry[] {\n  // Validate input\n  if (!isValidInput(navDataList)) return [];\n\n  // Prepare data\n  const numFunds = navDataList.length;\n  const actualAllocations = allocations.length === numFunds \n    ? allocations \n    : Array(numFunds).fill(100 / numFunds);\n  \n  const filledNavs = navDataList.map(ensureContinuousDates);\n  const fundDateMaps = filledNavs.map(buildDateMap);\n  const sorted = getSortedDates(filledNavs[0]);\n  const firstDate = sorted[0].date;\n  const months = years * 12;\n\n  // Calculate XIRR for each date\n  return sorted.flatMap(entry =>\n    computeLumpsumXirrForDate(\n      entry.date,\n      fundDateMaps,\n      sorted,\n      firstDate,\n      months,\n      actualAllocations,\n      investmentAmount,\n      includeNilTransactions\n    )\n  );\n}\n\n// ============================================================================\n// CORE COMPUTATION\n// ============================================================================\n\n/**\n * Compute Lumpsum XIRR for a single date\n * This is the orchestration function that coordinates all calculations\n */\nfunction computeLumpsumXirrForDate(\n  endDate: Date,\n  fundDateMaps: Map<string, NavEntry>[],\n  sorted: NavEntry[],\n  firstDate: Date,\n  months: number,\n  allocations: number[],\n  investmentAmount: number,\n  includeNilTransactions: boolean\n): RollingXirrEntry[] {\n  // Calculate start date\n  const startDate = getNthPreviousMonthDate(endDate, months);\n  if (startDate < firstDate) return [];\n\n  // Calculate units purchased at start for each fund\n  const fundUnits = calculateFundUnits(\n    fundDateMaps,\n    startDate,\n    allocations,\n    investmentAmount\n  );\n  if (!fundUnits) return [];\n\n  // Calculate total portfolio value at end date\n  const totalValue = calculateTotalValue(fundDateMaps, endDate, fundUnits);\n  if (totalValue === null) return [];\n\n  // Calculate XIRR\n  const xirrValue = calculateXirr(investmentAmount, totalValue, startDate, endDate);\n  if (xirrValue === null) return [];\n\n  // Build detailed transactions and calculate volatility\n  const allTransactions = buildDetailedTransactions(\n    fundDateMaps,\n    fundUnits,\n    allocations,\n    sorted,\n    startDate,\n    endDate,\n    investmentAmount\n  );\n\n  const volatility = calculateVolatilityForEntry(allTransactions);\n\n  // Filter nil transactions if not needed (for memory efficiency)\n  const transactionsToReturn = includeNilTransactions\n    ? allTransactions\n    : allTransactions.filter(tx => tx.type !== 'nil');\n\n  return [{\n    date: endDate,\n    xirr: Math.round(xirrValue * 10000) / 10000,\n    transactions: transactionsToReturn,\n    volatility: Math.round(volatility * 10000) / 10000\n  }];\n}\n\n/**\n * Calculate units purchased for each fund at start date\n */\nfunction calculateFundUnits(\n  fundDateMaps: Map<string, NavEntry>[],\n  startDate: Date,\n  allocations: number[],\n  investmentAmount: number\n): number[] | null {\n  const fundUnits: number[] = [];\n  const startKey = toDateKey(startDate);\n\n  for (let f = 0; f < fundDateMaps.length; f++) {\n    const startEntry = fundDateMaps[f].get(startKey);\n    if (!startEntry) return null;\n    \n    const fundAllocation = (investmentAmount * allocations[f]) / 100;\n    fundUnits[f] = fundAllocation / startEntry.nav;\n  }\n\n  return fundUnits;\n}\n\n/**\n * Calculate total portfolio value at end date\n */\nfunction calculateTotalValue(\n  fundDateMaps: Map<string, NavEntry>[],\n  endDate: Date,\n  fundUnits: number[]\n): number | null {\n  let totalValue = 0;\n  const endKey = toDateKey(endDate);\n\n  for (let f = 0; f < fundDateMaps.length; f++) {\n    const endEntry = fundDateMaps[f].get(endKey);\n    if (!endEntry) return null;\n    \n    totalValue += fundUnits[f] * endEntry.nav;\n  }\n\n  return totalValue;\n}\n\n/**\n * Calculate XIRR from initial investment and final value\n */\nfunction calculateXirr(\n  investmentAmount: number,\n  totalValue: number,\n  startDate: Date,\n  endDate: Date\n): number | null {\n  try {\n    return xirr([\n      { amount: -investmentAmount, when: startDate },\n      { amount: totalValue, when: endDate }\n    ]);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Build detailed transactions for all dates in the period\n */\nfunction buildDetailedTransactions(\n  fundDateMaps: Map<string, NavEntry>[],\n  fundUnits: number[],\n  allocations: number[],\n  sorted: NavEntry[],\n  startDate: Date,\n  endDate: Date,\n  investmentAmount: number\n): Transaction[] {\n  const transactions: Transaction[] = [];\n  const startKey = toDateKey(startDate);\n  const endKey = toDateKey(endDate);\n  \n  // Filter dates within the period\n  const periodDates = sorted.filter(\n    entry => entry.date >= startDate && entry.date <= endDate\n  );\n  \n  // Generate transactions for each day\n  for (const dateEntry of periodDates) {\n    const dateKey = toDateKey(dateEntry.date);\n    const isStartDate = dateKey === startKey;\n    const isEndDate = dateKey === endKey;\n    let totalPortfolioValue = 0;\n    const dayTransactions: Transaction[] = [];\n\n    // Create transaction for each fund\n    for (let fundIdx = 0; fundIdx < fundDateMaps.length; fundIdx++) {\n      const navEntry = fundDateMaps[fundIdx].get(dateKey);\n      if (!navEntry) continue;\n\n      const currentValue = fundUnits[fundIdx] * navEntry.nav;\n      totalPortfolioValue += currentValue;\n      const fundAllocation = (investmentAmount * allocations[fundIdx]) / 100;\n      \n      // Determine transaction type and amount\n      let type: 'buy' | 'sell' | 'nil' = 'nil';\n      let amount = 0;\n      \n      if (isStartDate) {\n        type = 'buy';\n        amount = -fundAllocation;\n      } else if (isEndDate) {\n        type = 'sell';\n        amount = currentValue;\n      }\n\n      dayTransactions.push({\n        fundIdx,\n        nav: navEntry.nav,\n        when: navEntry.date,\n        units: fundUnits[fundIdx],\n        amount,\n        type,\n        cumulativeUnits: fundUnits[fundIdx],\n        currentValue,\n        allocationPercentage: 0 // Calculated below\n      });\n    }\n\n    // Calculate allocation percentages\n    dayTransactions.forEach(tx => {\n      tx.allocationPercentage = totalPortfolioValue > 0 \n        ? (tx.currentValue / totalPortfolioValue) * 100 \n        : 0;\n    });\n\n    transactions.push(...dayTransactions);\n  }\n\n  return transactions;\n}\n\n// ============================================================================\n// ON-DEMAND RECALCULATION\n// ============================================================================\n\n/**\n * Recalculate transactions for a specific date with nil transactions included\n * Used for on-demand calculation when viewing transaction details in modal\n * \n * @param navDataList - Array of NAV data for each fund\n * @param targetDate - The specific date to recalculate for\n * @param years - Rolling period in years\n * @param allocations - Target allocation percentages for each fund\n * @param investmentAmount - Total investment amount\n * @returns Transaction array with nil transactions included, or null if calculation fails\n */\nexport function recalculateLumpsumTransactionsForDate(\n  navDataList: NavEntry[][],\n  targetDate: Date,\n  years: number,\n  allocations: number[],\n  investmentAmount: number = 100\n): Transaction[] | null {\n  // Validate input\n  if (!isValidInput(navDataList)) return null;\n\n  // Prepare data\n  const numFunds = navDataList.length;\n  const actualAllocations = allocations.length === numFunds \n    ? allocations \n    : Array(numFunds).fill(100 / numFunds);\n  \n  const filledNavs = navDataList.map(ensureContinuousDates);\n  const fundDateMaps = filledNavs.map(buildDateMap);\n  const sorted = getSortedDates(filledNavs[0]);\n  const firstDate = sorted[0].date;\n  const months = years * 12;\n\n  // Calculate start date\n  const startDate = getNthPreviousMonthDate(targetDate, months);\n  if (startDate < firstDate) return null;\n\n  // Calculate fund units\n  const fundUnits = calculateFundUnits(\n    fundDateMaps,\n    startDate,\n    actualAllocations,\n    investmentAmount\n  );\n  if (!fundUnits) return null;\n\n  // Build detailed transactions (with nil included)\n  const allTransactions = buildDetailedTransactions(\n    fundDateMaps,\n    fundUnits,\n    actualAllocations,\n    sorted,\n    startDate,\n    targetDate,\n    investmentAmount\n  );\n\n  return allTransactions;\n}\n"],"names":["newtonRaphsonMethod","newtonRaphson","f","fp","x0","options","x1","y","yp","tol","maxIter","iter","yph","ymh","yp2h","ym2h","h","hr","verbose","eps","newton","require$$0","MILLIS_PER_DAY","DAYS_IN_YEAR","convert","data","investments","start","end","minAmount","maxAmount","total","deposits","datum","epochDays","investment","xirr","transactions","value","rate","sum","A","Y","derivative","guess","xirr_1","MILLISECONDS_PER_DAY","areDatesContinuous","navData","sorted","a","b","i","prev","getNthPreviousMonthDate","currentDate","months","date","d","fillMissingNavDates","filled","current","last","sameDay","TRADING_DAYS_PER_YEAR","calculateVolatility","dailyValues","dailyReturns","calculateDailyReturns","meanReturn","r","variance","diff","returns","previousValue","currentValue","dailyReturn","calculateVolatilityForEntry","extractDailyPortfolioValues","dailyValuesMap","tx","dateKey","existing","dateStr","totalValue","toDateKey","buildDateMap","fund","entry","ensureContinuousDates","isValidInput","navDataList","getSortedDates","calculateLumpSumRollingXirr","years","allocations","investmentAmount","includeNilTransactions","numFunds","actualAllocations","filledNavs","fundDateMaps","firstDate","computeLumpsumXirrForDate","endDate","startDate","fundUnits","calculateFundUnits","calculateTotalValue","xirrValue","calculateXirr","allTransactions","buildDetailedTransactions","volatility","transactionsToReturn","startKey","startEntry","fundAllocation","endKey","endEntry","periodDates","dateEntry","isStartDate","isEndDate","totalPortfolioValue","dayTransactions","fundIdx","navEntry","type","amount","recalculateLumpsumTransactionsForDate","targetDate"],"mappings":"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","x_google_ignoreList":[0,1]}