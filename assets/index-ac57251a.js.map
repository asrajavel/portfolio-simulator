{"version":3,"file":"index-ac57251a.js","sources":["../src/utils/date/dateUtils.ts","../src/utils/data/fillMissingNavDates.ts","../src/utils/calculations/sipRollingXirr/core/helpers.ts","../src/utils/calculations/sipRollingXirr/transactions/buy.ts","../src/utils/calculations/sipRollingXirr/transactions/rebalance.ts","../src/utils/calculations/sipRollingXirr/transactions/nil.ts","../src/utils/calculations/sipRollingXirr/transactions/sell.ts","../src/utils/calculations/sipRollingXirr/core/transactionBuilder.ts","../node_modules/newton-raphson-method/index.js","../node_modules/xirr/xirr.js","../src/utils/calculations/sipRollingXirr/core/xirrCalculator.ts","../src/utils/calculations/sipRollingXirr/volatility/volatilityCalculator.ts","../src/utils/calculations/sipRollingXirr/index.ts"],"sourcesContent":["// Date utility functions for NAV and lump sum rolling XIRR calculations\nimport { NavEntry } from '../../types/navData';\nimport { MILLISECONDS_PER_DAY } from '../../constants';\n\nexport function areDatesContinuous(navData: NavEntry[]): boolean {\n  if (navData.length < 2) return true;\n  const sorted = [...navData].sort((a, b) => a.date.getTime() - b.date.getTime());\n  for (let i = 1; i < sorted.length; i++) {\n    const prev = sorted[i - 1].date;\n    const curr = sorted[i].date;\n    const diff = (curr.getTime() - prev.getTime()) / MILLISECONDS_PER_DAY;\n    if (diff !== 1) return false;\n  }\n  return true;\n}\n\n// Get the date N months before a given date, handling month-end edge cases\nexport function getNthPreviousMonthDate(currentDate: Date, months: number): Date {\n  const date = new Date(currentDate);\n  const d = date.getDate();\n  date.setMonth(date.getMonth() - months);\n  // Handle month-end edge case (e.g., March 31 -> Feb 28/29)\n  if (date.getDate() < d) {\n    date.setDate(0); // Go to last day of previous month\n  }\n  return date;\n} ","import { NavEntry } from '../../types/navData';\n\nexport function fillMissingNavDates(navData: NavEntry[]): NavEntry[] {\n  if (navData.length === 0) return [];\n\n  // Sort ascending (oldest first)\n  const sorted = [...navData].sort((a, b) => a.date.getTime() - b.date.getTime());\n  const filled: NavEntry[] = [];\n  let i = 0;\n  let current = new Date(sorted[0].date);\n  const last = sorted[sorted.length - 1].date;\n\n  while (current <= last) {\n    if (i < sorted.length && sameDay(current, sorted[i].date)) {\n      filled.push({ date: new Date(current), nav: sorted[i].nav });\n      i++;\n    } else {\n      // Use the next available NAV (forward fill)\n      filled.push({ date: new Date(current), nav: sorted[i].nav });\n    }\n    current.setDate(current.getDate() + 1);\n  }\n  return filled;\n}\n\nfunction sameDay(a: Date, b: Date) {\n  return a.getFullYear() === b.getFullYear() &&\n    a.getMonth() === b.getMonth() &&\n    a.getDate() === b.getDate();\n} ","import { NavEntry } from '../../../../types/navData';\nimport { areDatesContinuous, getNthPreviousMonthDate } from '../../../date/dateUtils';\nimport { fillMissingNavDates } from '../../../data/fillMissingNavDates';\n\nexport function isValidInput(navDataList: NavEntry[][]): boolean {\n  return navDataList.length > 0 && !navDataList.some(f => f.length < 2);\n}\n\nexport function ensureContinuousDates(fund: NavEntry[]): NavEntry[] {\n  return areDatesContinuous(fund) ? fund : fillMissingNavDates(fund);\n}\n\nexport function buildDateMap(fund: NavEntry[]): Map<string, NavEntry> {\n  return new Map(fund.map(entry => [toDateKey(entry.date), entry]));\n}\n\nexport function getSortedDates(fund: NavEntry[]): Date[] {\n  return [...fund]\n    .sort((a, b) => a.date.getTime() - b.date.getTime())\n    .map(entry => entry.date);\n}\n\nexport function toDateKey(date: Date): string {\n  return date.toISOString().split('T')[0];\n}\n\n// ────────────── SIP Date Generation ────────────── //\n\nexport interface SipDatesResult {\n  dateSet: Set<string>;\n  earliestDate: Date | null;\n}\n\nexport function generateSipDates(\n  currentDate: Date,\n  months: number,\n  firstDate: Date\n): SipDatesResult {\n  const sipDates = new Set<string>();\n  let earliestSipDate: Date | null = null;\n\n  for (let m = months; m >= 1; m--) {\n    const sipDate = getNthPreviousMonthDate(currentDate, m);\n    if (sipDate < firstDate) {\n      return { dateSet: sipDates, earliestDate: null };\n    }\n\n    sipDates.add(toDateKey(sipDate));\n    if (!earliestSipDate || sipDate < earliestSipDate) {\n      earliestSipDate = sipDate;\n    }\n  }\n\n  return { dateSet: sipDates, earliestDate: earliestSipDate };\n}\n\n/**\n * Calculate which investment year a given date falls into, starting from the first SIP date\n * Used for step-up SIP calculations where investment amount increases yearly\n * \n * @param currentDate - The date to check\n * @param firstSipDate - The first SIP date (year 1 starts from this date)\n * @returns The investment year (1-based: 1 for first year, 2 for second year, etc.)\n */\nexport function getInvestmentYear(currentDate: Date, firstSipDate: Date): number {\n  const yearsDiff = currentDate.getFullYear() - firstSipDate.getFullYear();\n  const monthsDiff = currentDate.getMonth() - firstSipDate.getMonth();\n  const totalYears = yearsDiff + (monthsDiff >= 0 ? 0 : -1);\n  return totalYears + 1; // Return 1-based year\n}\n\n","import { NavEntry } from '../../../../types/navData';\nimport { Transaction } from '../types';\nimport { getInvestmentYear } from '../core/helpers';\n\ninterface BuyTransactionsResult {\n  transactions: Transaction[];\n  portfolioValue: number;\n}\n\ninterface TransactionState {\n  cumulativeUnits: number[];\n  unitsPerFund: number[];\n}\n\n/**\n * Create buy transactions for a SIP date\n */\nexport function createBuyTransactions(\n  dateKey: string,\n  fundDateMaps: Map<string, NavEntry>[],\n  allocations: number[],\n  state: TransactionState,\n  currentDate: Date,\n  firstSipDate: Date,\n  stepUpEnabled: boolean,\n  stepUpPercentage: number,\n  sipAmount: number\n): BuyTransactionsResult | null {\n  // Calculate investment with step-up if enabled\n  let totalInvestment = sipAmount;\n  \n  if (stepUpEnabled && stepUpPercentage > 0) {\n    const investmentYear = getInvestmentYear(currentDate, firstSipDate);\n    // Apply compound step-up: Year 1 = sipAmount, Year 2 = sipAmount * (1 + r), Year 3 = sipAmount * (1 + r)^2, etc.\n    totalInvestment = sipAmount * Math.pow(1 + stepUpPercentage / 100, investmentYear - 1);\n  }\n  const transactions: Transaction[] = [];\n  let totalPortfolioValue = 0;\n  const fundValues: number[] = [];\n\n  for (let fundIdx = 0; fundIdx < fundDateMaps.length; fundIdx++) {\n    const entry = fundDateMaps[fundIdx].get(dateKey);\n    if (!entry) return null;\n\n    const investmentAmount = totalInvestment * (allocations[fundIdx] / 100);\n    const units = investmentAmount / entry.nav;\n\n    state.cumulativeUnits[fundIdx] += units;\n    state.unitsPerFund[fundIdx] += units;\n\n    const currentValue = state.cumulativeUnits[fundIdx] * entry.nav;\n    fundValues.push(currentValue);\n    totalPortfolioValue += currentValue;\n\n    transactions.push({\n      fundIdx,\n      nav: entry.nav,\n      when: entry.date,\n      units,\n      amount: -investmentAmount,\n      type: 'buy',\n      cumulativeUnits: state.cumulativeUnits[fundIdx],\n      currentValue,\n      allocationPercentage: 0,\n    });\n  }\n\n  transactions.forEach((tx, idx) => {\n    tx.allocationPercentage = totalPortfolioValue > 0 ? (fundValues[idx] / totalPortfolioValue) * 100 : 0;\n  });\n\n  return { transactions, portfolioValue: totalPortfolioValue };\n}\n\n","import { NavEntry } from '../../../../types/navData';\nimport { Transaction } from '../types';\n\ninterface TransactionState {\n  cumulativeUnits: number[];\n  unitsPerFund: number[];\n}\n\n/**\n * Create rebalance transactions if needed\n */\nexport function createRebalanceTransactions(\n  dateKey: string,\n  loopDate: Date,\n  fundDateMaps: Map<string, NavEntry>[],\n  allocations: number[],\n  rebalancingThreshold: number,\n  portfolioValue: number,\n  state: TransactionState\n): Transaction[] | null {\n  if (!isRebalancingNeeded(state.cumulativeUnits, fundDateMaps, dateKey, allocations, rebalancingThreshold, portfolioValue)) {\n    return [];\n  }\n\n  const transactions: Transaction[] = [];\n\n  for (let fundIdx = 0; fundIdx < fundDateMaps.length; fundIdx++) {\n    const entry = fundDateMaps[fundIdx].get(dateKey);\n    if (!entry) return null;\n\n    const currentValue = state.cumulativeUnits[fundIdx] * entry.nav;\n    const targetValue = portfolioValue * (allocations[fundIdx] / 100);\n    const rebalanceAmount = targetValue - currentValue;\n\n    if (Math.abs(rebalanceAmount) > 0.01) {\n      const rebalanceUnits = rebalanceAmount / entry.nav;\n\n      state.cumulativeUnits[fundIdx] += rebalanceUnits;\n      state.unitsPerFund[fundIdx] += rebalanceUnits;\n\n      transactions.push({\n        fundIdx,\n        when: new Date(loopDate),\n        nav: entry.nav,\n        units: rebalanceUnits,\n        amount: -rebalanceAmount,\n        type: 'rebalance',\n        cumulativeUnits: state.cumulativeUnits[fundIdx],\n        currentValue: state.cumulativeUnits[fundIdx] * entry.nav,\n        allocationPercentage: allocations[fundIdx],\n      });\n    }\n  }\n\n  return transactions;\n}\n\nfunction isRebalancingNeeded(\n  cumulativeUnits: number[],\n  fundDateMaps: Map<string, NavEntry>[],\n  dateKey: string,\n  allocations: number[],\n  threshold: number,\n  portfolioValue: number\n): boolean {\n  for (let fundIdx = 0; fundIdx < fundDateMaps.length; fundIdx++) {\n    const entry = fundDateMaps[fundIdx].get(dateKey);\n    if (!entry) continue;\n\n    const currentValue = cumulativeUnits[fundIdx] * entry.nav;\n    const currentAllocation = (currentValue / portfolioValue) * 100;\n    const targetAllocation = allocations[fundIdx];\n\n    if (Math.abs(currentAllocation - targetAllocation) > threshold) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n","import { NavEntry } from '../../../../types/navData';\nimport { Transaction } from '../types';\n\ninterface TransactionState {\n  cumulativeUnits: number[];\n}\n\n/**\n * Create nil transactions for non-SIP dates (showing current holdings)\n */\nexport function createNilTransactions(\n  dateKey: string,\n  fundDateMaps: Map<string, NavEntry>[],\n  state: Pick<TransactionState, 'cumulativeUnits'>\n): Transaction[] | null {\n  const transactions: Transaction[] = [];\n  let totalPortfolioValue = 0;\n\n  for (let fundIdx = 0; fundIdx < fundDateMaps.length; fundIdx++) {\n    const entry = fundDateMaps[fundIdx].get(dateKey);\n    if (!entry) return null;\n\n    const currentValue = state.cumulativeUnits[fundIdx] * entry.nav;\n    totalPortfolioValue += currentValue;\n\n    transactions.push({\n      fundIdx,\n      when: entry.date,\n      nav: entry.nav,\n      units: 0,\n      amount: 0,\n      type: 'nil',\n      cumulativeUnits: state.cumulativeUnits[fundIdx],\n      currentValue,\n      allocationPercentage: 0,\n    });\n  }\n\n  transactions.forEach(tx => {\n    tx.allocationPercentage = totalPortfolioValue > 0 ? (tx.currentValue / totalPortfolioValue) * 100 : 0;\n  });\n\n  return transactions;\n}\n\n","import { NavEntry } from '../../../../types/navData';\nimport { Transaction } from '../types';\nimport { toDateKey } from '../core/helpers';\n\n/**\n * Create final sell transactions at the end date\n */\nexport function createFinalSellTransactions(\n  currentDate: Date,\n  fundDateMaps: Map<string, NavEntry>[],\n  unitsPerFund: number[]\n): Transaction[] | null {\n  const dateKey = toDateKey(currentDate);\n  const sells: Transaction[] = [];\n\n  for (let fundIdx = 0; fundIdx < fundDateMaps.length; fundIdx++) {\n    const entry = fundDateMaps[fundIdx].get(dateKey);\n    if (!entry) return null;\n\n    const units = unitsPerFund[fundIdx];\n    const amount = units * entry.nav;\n\n    sells.push({\n      fundIdx,\n      nav: entry.nav,\n      when: entry.date,\n      units,\n      amount,\n      type: 'sell',\n      cumulativeUnits: units,\n      currentValue: units * entry.nav,\n    });\n  }\n\n  return sells;\n}\n\n","import { NavEntry } from '../../../../types/navData';\nimport { Transaction } from '../types';\nimport { toDateKey, generateSipDates } from './helpers';\nimport { createBuyTransactions } from '../transactions/buy';\nimport { createRebalanceTransactions } from '../transactions/rebalance';\nimport { createNilTransactions } from '../transactions/nil';\nimport { createFinalSellTransactions } from '../transactions/sell';\nimport { DailySipPortfolioValue } from '../volatility/sipPortfolioValue';\n\n/**\n * Result of transaction calculation - includes both transactions and daily values for volatility\n */\nexport interface TransactionResult {\n  transactions: Transaction[];\n  dailyValues: DailySipPortfolioValue[];\n}\n\n/**\n * Calculate all transactions for a given date, including buy/rebalance transactions\n * and the final sell transaction at the end date.\n * Also computes daily portfolio values inline for volatility calculation.\n * \n * OPTIMIZATION: Nil transactions are NOT created as objects - daily values are computed directly.\n */\nexport function calculateTransactionsForDate(\n  currentDate: Date,\n  fundDateMaps: Map<string, NavEntry>[],\n  months: number,\n  firstDate: Date,\n  allocations: number[],\n  rebalancingEnabled: boolean,\n  rebalancingThreshold: number,\n  stepUpEnabled: boolean,\n  stepUpPercentage: number,\n  sipAmount: number\n): TransactionResult | null {\n  const sipDates = generateSipDates(currentDate, months, firstDate);\n  if (!sipDates.earliestDate) {\n    return null;\n  }\n\n  const state = initializeState(fundDateMaps.length);\n  const result = buildDailyTransactions(\n    sipDates.earliestDate,\n    currentDate,\n    sipDates.dateSet,\n    fundDateMaps,\n    allocations,\n    rebalancingEnabled,\n    rebalancingThreshold,\n    stepUpEnabled,\n    stepUpPercentage,\n    sipAmount,\n    state\n  );\n\n  if (!result) return null;\n\n  // Add final selling transactions at current date\n  const sellTransactions = createFinalSellTransactions(currentDate, fundDateMaps, state.unitsPerFund);\n  if (!sellTransactions) return null;\n\n  return {\n    transactions: [...result.transactions, ...sellTransactions],\n    dailyValues: result.dailyValues\n  };\n}\n\n/**\n * Calculate transactions WITH nil transactions included (for modal display)\n * This is the slower path, only used when user clicks on a data point\n */\nexport function calculateTransactionsForDateWithNil(\n  currentDate: Date,\n  fundDateMaps: Map<string, NavEntry>[],\n  months: number,\n  firstDate: Date,\n  allocations: number[],\n  rebalancingEnabled: boolean,\n  rebalancingThreshold: number,\n  stepUpEnabled: boolean,\n  stepUpPercentage: number,\n  sipAmount: number\n): Transaction[] | null {\n  const sipDates = generateSipDates(currentDate, months, firstDate);\n  if (!sipDates.earliestDate) {\n    return null;\n  }\n\n  const state = initializeState(fundDateMaps.length);\n  const transactions = buildDailyTransactionsWithNil(\n    sipDates.earliestDate,\n    currentDate,\n    sipDates.dateSet,\n    fundDateMaps,\n    allocations,\n    rebalancingEnabled,\n    rebalancingThreshold,\n    stepUpEnabled,\n    stepUpPercentage,\n    sipAmount,\n    state\n  );\n\n  if (!transactions) return null;\n\n  // Add final selling transactions at current date\n  const sellTransactions = createFinalSellTransactions(currentDate, fundDateMaps, state.unitsPerFund);\n  if (!sellTransactions) return null;\n\n  return [...transactions, ...sellTransactions];\n}\n\n// ────────────── Private Helpers ────────────── //\n\ninterface TransactionState {\n  unitsPerFund: number[];\n  cumulativeUnits: number[];\n}\n\nfunction initializeState(numFunds: number): TransactionState {\n  return {\n    unitsPerFund: new Array(numFunds).fill(0),\n    cumulativeUnits: new Array(numFunds).fill(0),\n  };\n}\n\n/**\n * OPTIMIZED: Build transactions WITHOUT creating nil transaction objects.\n * Daily portfolio values are computed inline for volatility calculation.\n */\nfunction buildDailyTransactions(\n  startDate: Date,\n  endDate: Date,\n  sipDates: Set<string>,\n  fundDateMaps: Map<string, NavEntry>[],\n  allocations: number[],\n  rebalancingEnabled: boolean,\n  rebalancingThreshold: number,\n  stepUpEnabled: boolean,\n  stepUpPercentage: number,\n  sipAmount: number,\n  state: TransactionState\n): { transactions: Transaction[]; dailyValues: DailySipPortfolioValue[] } | null {\n  const transactions: Transaction[] = [];\n  const dailyValues: DailySipPortfolioValue[] = [];\n  const loopDate = new Date(startDate);\n  const firstSipDate = new Date(startDate);\n\n  while (loopDate <= endDate) {\n    const dateKey = toDateKey(loopDate);\n    // Don't process SIP on the final day (it's the sell date, not a buy date)\n    const isSipDate = loopDate < endDate && sipDates.has(dateKey);\n\n    let cashFlowForDay = 0;\n    if (isSipDate) {\n      const result = processSipDate(dateKey, loopDate, fundDateMaps, allocations, rebalancingEnabled, rebalancingThreshold, firstSipDate, stepUpEnabled, stepUpPercentage, sipAmount, state);\n      if (!result) return null;\n      transactions.push(...result);\n      \n      // Calculate actual cash flow from transactions created (handles step-up and rebalancing)\n      cashFlowForDay = result\n        .filter(tx => tx.type === 'buy')\n        .reduce((sum, tx) => sum + tx.amount, 0);\n    }\n\n    // Compute daily portfolio value inline (no nil transactions created)\n    const dailyValue = computeDailyPortfolioValue(dateKey, loopDate, fundDateMaps, state, cashFlowForDay);\n    if (!dailyValue) return null;\n    dailyValues.push(dailyValue);\n\n    loopDate.setDate(loopDate.getDate() + 1);\n  }\n\n  return { transactions, dailyValues };\n}\n\n/**\n * OLD PATH: Build transactions WITH nil transaction objects (for modal display)\n */\nfunction buildDailyTransactionsWithNil(\n  startDate: Date,\n  endDate: Date,\n  sipDates: Set<string>,\n  fundDateMaps: Map<string, NavEntry>[],\n  allocations: number[],\n  rebalancingEnabled: boolean,\n  rebalancingThreshold: number,\n  stepUpEnabled: boolean,\n  stepUpPercentage: number,\n  sipAmount: number,\n  state: TransactionState\n): Transaction[] | null {\n  const transactions: Transaction[] = [];\n  const loopDate = new Date(startDate);\n  const firstSipDate = new Date(startDate);\n\n  while (loopDate < endDate) {\n    const dateKey = toDateKey(loopDate);\n    const isSipDate = sipDates.has(dateKey);\n\n    const result = isSipDate\n      ? processSipDate(dateKey, loopDate, fundDateMaps, allocations, rebalancingEnabled, rebalancingThreshold, firstSipDate, stepUpEnabled, stepUpPercentage, sipAmount, state)\n      : processNilDate(dateKey, fundDateMaps, state);\n\n    if (!result) return null;\n    transactions.push(...result);\n\n    loopDate.setDate(loopDate.getDate() + 1);\n  }\n\n  return transactions;\n}\n\n/**\n * Compute daily portfolio value without creating transaction objects\n */\nfunction computeDailyPortfolioValue(\n  dateKey: string,\n  date: Date,\n  fundDateMaps: Map<string, NavEntry>[],\n  state: TransactionState,\n  cashFlow: number\n): DailySipPortfolioValue | null {\n  let totalValue = 0;\n\n  for (let fundIdx = 0; fundIdx < fundDateMaps.length; fundIdx++) {\n    const entry = fundDateMaps[fundIdx].get(dateKey);\n    if (!entry) return null;\n\n    const currentValue = state.cumulativeUnits[fundIdx] * entry.nav;\n    totalValue += currentValue;\n  }\n\n  return {\n    date: new Date(date),\n    totalValue,\n    cashFlow\n  };\n}\n\nfunction processSipDate(\n  dateKey: string,\n  loopDate: Date,\n  fundDateMaps: Map<string, NavEntry>[],\n  allocations: number[],\n  rebalancingEnabled: boolean,\n  rebalancingThreshold: number,\n  firstSipDate: Date,\n  stepUpEnabled: boolean,\n  stepUpPercentage: number,\n  sipAmount: number,\n  state: TransactionState\n): Transaction[] | null {\n  const buyResult = createBuyTransactions(dateKey, fundDateMaps, allocations, state, loopDate, firstSipDate, stepUpEnabled, stepUpPercentage, sipAmount);\n  if (!buyResult) return null;\n\n  const rebalanceTransactions = rebalancingEnabled\n    ? createRebalanceTransactions(dateKey, loopDate, fundDateMaps, allocations, rebalancingThreshold, buyResult.portfolioValue, state)\n    : [];\n\n  if (rebalanceTransactions === null) return null;\n\n  return [...buyResult.transactions, ...rebalanceTransactions];\n}\n\nfunction processNilDate(\n  dateKey: string,\n  fundDateMaps: Map<string, NavEntry>[],\n  state: TransactionState\n): Transaction[] | null {\n  return createNilTransactions(dateKey, fundDateMaps, state);\n}\n\n","'use strict';\n\nmodule.exports = newtonRaphson;\n\nfunction newtonRaphson (f, fp, x0, options) {\n  var x1, y, yp, tol, maxIter, iter, yph, ymh, yp2h, ym2h, h, hr, verbose, eps;\n\n  // Iterpret variadic forms:\n  if (typeof fp !== 'function') {\n    options = x0;\n    x0 = fp;\n    fp = null;\n  }\n\n  options = options || {};\n  tol = options.tolerance === undefined ? 1e-7 : options.tolerance;\n  eps = options.epsilon === undefined ? 2.220446049250313e-16 : options.epsilon;\n  maxIter = options.maxIterations === undefined ? 20 : options.maxIterations;\n  h = options.h === undefined ? 1e-4 : options.h;\n  verbose = options.verbose === undefined ? false : options.verbose;\n  hr = 1 / h;\n\n  iter = 0;\n  while (iter++ < maxIter) {\n    // Compute the value of the function:\n    y = f(x0);\n\n    if (fp) {\n      yp = fp(x0);\n    } else {\n      // Needs numerical derivatives:\n      yph = f(x0 + h);\n      ymh = f(x0 - h);\n      yp2h = f(x0 + 2 * h);\n      ym2h = f(x0 - 2 * h);\n\n      yp = ((ym2h - yp2h) + 8 * (yph - ymh)) * hr / 12;\n    }\n\n    // Check for badly conditioned update (extremely small first deriv relative to function):\n    if (Math.abs(yp) <= eps * Math.abs(y)) {\n      if (verbose) {\n        console.log('Newton-Raphson: failed to converged due to nearly zero first derivative');\n      }\n      return false;\n    }\n\n    // Update the guess:\n    x1 = x0 - y / yp;\n\n    // Check for convergence:\n    if (Math.abs(x1 - x0) <= tol * Math.abs(x1)) {\n      if (verbose) {\n        console.log('Newton-Raphson: converged to x = ' + x1 + ' after ' + iter + ' iterations');\n      }\n      return x1;\n    }\n\n    // Transfer update to the new guess:\n    x0 = x1;\n  }\n\n  if (verbose) {\n    console.log('Newton-Raphson: Maximum iterations reached (' + maxIter + ')');\n  }\n\n  return false;\n}\n","'use strict';\n\nvar newton = require('newton-raphson-method');\n\nvar MILLIS_PER_DAY = 1000*60*60*24;\nvar DAYS_IN_YEAR = 365;\n\nfunction convert(data) {\n    if (!data || !data.length || !data.forEach || data.length < 2) {\n        throw new Error('Argument is not an array with length of 2 or more.');\n    }\n\n    var investments = [];\n    var start = Math.floor(data[0].when/MILLIS_PER_DAY);\n    var end = start;\n    var minAmount = Number.POSITIVE_INFINITY;\n    var maxAmount = Number.NEGATIVE_INFINITY;\n    var total = 0;\n    var deposits = 0;\n    data.forEach(function(datum) {\n        total += datum.amount;\n        if (datum.amount < 0) {\n            deposits += -datum.amount;\n        }\n        var epochDays = Math.floor(datum.when/MILLIS_PER_DAY);\n        start = Math.min(start, epochDays);\n        end = Math.max(end, epochDays);\n        minAmount = Math.min(minAmount, datum.amount);\n        maxAmount = Math.max(maxAmount, datum.amount);\n        investments.push({\n            amount: datum.amount,\n            epochDays: epochDays\n        });\n    });\n    if (start === end) {\n        throw new Error('Transactions must not all be on the same day.');\n    }\n    if (minAmount >= 0) {\n        throw new Error('Transactions must not all be nonnegative.');\n    }\n    if (maxAmount < 0) {\n        throw new Error('Transactions must not all be negative.');\n    }\n    investments.forEach(function(investment) {\n        // Number of years (including fraction) this item applies\n        investment.years = (end - investment.epochDays) / DAYS_IN_YEAR;\n    });\n    return {\n        total: total,\n        deposits: deposits,\n        days: end - start,\n        investments: investments,\n        maxAmount: maxAmount\n    };\n}\n\nfunction xirr(transactions, options) {\n    var data = convert(transactions);\n    if (data.maxAmount === 0) {\n        return -1;\n    }\n    var investments = data.investments;\n    var value = function(rate) {\n        return investments.reduce(function(sum, investment) {\n            // Make the vars more Math-y, makes the derivative easier to see\n            var A = investment.amount;\n            var Y = investment.years;\n            if (-1 < rate) {\n                return sum + A * Math.pow(1+rate, Y);\n            } else if (rate < -1) {\n                // Extend the function into the range where the rate is less\n                // than -100%.  Even though this does not make practical sense,\n                // it allows the algorithm to converge in the cases where the\n                // candidate values enter this range\n\n                // We cannot use the same formula as before, since the base of\n                // the exponent (1+rate) is negative, this yields imaginary\n                // values for fractional years.\n                // E.g. if rate=-1.5 and years=.5, it would be (-.5)^.5,\n                // i.e. the square root of negative one half.\n\n                // Ensure the values are always negative so there can never\n                // be a zero (as long as some amount is non-zero).\n                // This formula also ensures that the derivative is positive\n                // (when rate < -1) so that Newton's method is encouraged to \n                // move the candidate values towards the proper range\n\n                return sum - Math.abs(A) * Math.pow(-1-rate, Y);\n            } else if (Y === 0) {\n                return sum + A;  // Treat 0^0 as 1\n            } else {\n                return sum;\n            }\n        }, 0);\n    };\n    var derivative = function(rate) {\n        return investments.reduce(function(sum, investment) {\n            // Make the vars more Math-y, makes the derivative easier to see\n            var A = investment.amount;\n            var Y = investment.years;\n            if (Y === 0) {\n                return sum;\n            } else if (-1 < rate) {\n                return sum + A * Y * Math.pow(1+rate, Y-1);\n            } else if (rate < -1) {\n                return sum + Math.abs(A) * Y * Math.pow(-1-rate, Y-1);\n            } else {\n                return sum;\n            }\n        }, 0);\n    };\n    var guess = options ? options.guess : undefined;\n    if (guess && isNaN(guess)) {\n        throw new Error(\"option.guess must be a number.\");\n    }\n    if (!guess) {\n        guess = (data.total / data.deposits) / (data.days/DAYS_IN_YEAR);\n    }\n    var rate = newton(value, derivative, guess, options);\n    if (rate === false) {  // truthiness strikes again, !rate is true when rate is zero\n        throw new Error(\"Newton-Raphson algorithm failed to converge.\");\n    }\n    return rate;\n}\n\nmodule.exports = xirr;\n","import xirr from 'xirr';\nimport { Transaction } from '../types';\nimport { toDateKey } from './helpers';\n\n/**\n * Calculate XIRR from a list of transactions\n * \n * @param transactions - Array of transactions (buy, sell, rebalance, nil)\n * @param currentDate - Current date for error logging\n * @returns XIRR value or null if calculation fails\n */\nexport function calculateXirrFromTransactions(\n  transactions: Transaction[],\n  currentDate: Date\n): number | null {\n  const cashflows = aggregateCashflows(transactions);\n  return calculateXirr(cashflows, currentDate);\n}\n\n// ────────────── Private Helpers ────────────── //\n\nfunction aggregateCashflows(transactions: Transaction[]): Array<{ amount: number; when: Date }> {\n  const cashflowsMap = new Map<string, number>();\n\n  for (const tx of transactions) {\n    if (tx.type === 'nil') continue; // Skip nil transactions (amount: 0, just overhead)\n\n    const dateKey = toDateKey(tx.when);\n    const currentAmount = cashflowsMap.get(dateKey) || 0;\n    cashflowsMap.set(dateKey, currentAmount + tx.amount);\n  }\n\n  const cashflows = Array.from(cashflowsMap.entries()).map(([dateStr, amount]) => ({\n    amount,\n    when: new Date(dateStr),\n  }));\n\n  cashflows.sort((a, b) => a.when.getTime() - b.when.getTime());\n\n  return cashflows;\n}\n\nfunction calculateXirr(cashflows: Array<{ amount: number; when: Date }>, currentDate: Date): number | null {\n  try {\n    return xirr(cashflows);\n  } catch (error) {\n    console.warn(`XIRR calculation failed for date ${currentDate.toISOString()}:`, error);\n    return null;\n  }\n}\n\n","import { DailySipPortfolioValue } from './sipPortfolioValue';\n\nconst TRADING_DAYS_PER_YEAR = 252;\n\n/**\n * Calculate portfolio volatility from daily portfolio values\n * Returns annualized volatility as a percentage\n * \n * Automatically excludes forward-filled weekends/holidays (where value didn't change)\n * and adjusts annualization based on actual trading days in the data\n */\nexport function calculateVolatility(\n  dailyValues: DailySipPortfolioValue[]\n): number {\n  // Need at least 2 data points to calculate volatility\n  if (dailyValues.length < 2) {\n    return 0;\n  }\n\n  // Calculate daily returns (excludes forward-filled non-trading days)\n  const dailyReturns = calculateDailyReturns(dailyValues);\n\n  // Need at least 2 returns to calculate volatility\n  if (dailyReturns.length < 2) {\n    return 0;\n  }\n\n  // Calculate mean return\n  const meanReturn = dailyReturns.reduce((sum, r) => sum + r, 0) / dailyReturns.length;\n\n  // Calculate variance\n  const variance = dailyReturns.reduce((sum, r) => {\n    const diff = r - meanReturn;\n    return sum + (diff * diff);\n  }, 0) / dailyReturns.length;\n\n  // Calculate standard deviation (daily volatility)\n  const dailyVolatility = Math.sqrt(variance);\n\n  // Calculate trading days per year based on actual data\n  // If we have 365 days but only 252 returns (69% ratio), annualize accordingly\n  const totalDays = dailyValues.length - 1; // Subtract 1 since we calculate returns between days\n  const tradingDays = dailyReturns.length;\n  const tradingDaysPerYear = totalDays > 0 \n    ? Math.round((tradingDays / totalDays) * 365)\n    : TRADING_DAYS_PER_YEAR; // Default to 252 if calculation fails\n\n  // Annualize volatility using calculated trading days\n  const annualizedVolatility = dailyVolatility * Math.sqrt(tradingDaysPerYear);\n\n  const volatilityPercent = (annualizedVolatility * 100) || 0;\n\n  return volatilityPercent;\n}\n\n/**\n * Calculate daily returns from portfolio values\n * Daily Return = (Today's Value - Yesterday's Value + Cash Flow) / Yesterday's Value\n * \n * Adjusts for cash flows to get true market returns:\n * - On buy days: valueChange + (-100) removes the 100 investment from the increase\n * - On nil days: valueChange + 0 = no adjustment needed\n * - This isolates the market movement from cash flow effects\n * \n * Skips forward-filled days (weekends/holidays) where:\n * - Portfolio value didn't change AND\n * - No cash flow occurred (no actual transaction)\n * This prevents artificially low volatility from zero returns on non-trading days\n */\nfunction calculateDailyReturns(dailyValues: DailySipPortfolioValue[]): number[] {\n  const returns: number[] = [];\n\n  // Calculate returns from consecutive days (array is already sorted and continuous)\n  for (let i = 1; i < dailyValues.length; i++) {\n    const previousEntry = dailyValues[i - 1];\n    const currentEntry = dailyValues[i];\n\n    if (previousEntry.totalValue > 0) {\n      const valueChange = currentEntry.totalValue - previousEntry.totalValue;\n      \n      // Skip forward-filled days (weekends/holidays) where value didn't change and no cash flow\n      // This prevents artificially low volatility from zero returns on non-trading days\n      if (valueChange === 0 && currentEntry.cashFlow === 0) {\n        continue; // Skip this day - it's a forward-filled non-trading day\n      }\n      \n      // Adjust for cash flow to get true market return\n      // currentEntry.cashFlow is negative for buy (money out)\n      // We ADD cashFlow to remove investment effect from value change\n      const marketReturn = (valueChange + currentEntry.cashFlow) / previousEntry.totalValue;\n      \n      returns.push(marketReturn);\n    }\n  }\n\n  return returns;\n}\n\n","import { NavEntry } from '../../../types/navData';\nimport { SipRollingXirrEntry, Transaction } from './types';\nimport { isValidInput, ensureContinuousDates, buildDateMap, getSortedDates } from './core/helpers';\nimport { calculateTransactionsForDate, calculateTransactionsForDateWithNil } from './core/transactionBuilder';\nimport { calculateXirrFromTransactions } from './core/xirrCalculator';\nimport { calculateVolatility } from './volatility/volatilityCalculator';\n\n// Re-export types for backward compatibility\nexport type { SipRollingXirrEntry, Transaction } from './types';\n\n// Timing accumulators for performance analysis\nlet _xirrTime = 0;\nlet _volatilityTime = 0;\nlet _transactionTime = 0;\n\n/**\n * Calculate SIP Rolling XIRR for given NAV data\n * \n * @param navDataList - Array of NAV data for each fund\n * @param years - Rolling period in years (default: 1)\n * @param allocations - Target allocation percentages for each fund\n * @param rebalancingEnabled - Whether to enable portfolio rebalancing (default: false)\n * @param rebalancingThreshold - Threshold percentage for triggering rebalancing (default: 5)\n * @param includeNilTransactions - Whether to include nil transactions in result (default: false, set true for tests)\n * @param stepUpEnabled - Whether to enable step-up SIP (default: false)\n * @param stepUpPercentage - Annual percentage increase for step-up SIP (default: 0)\n * @param sipAmount - Monthly SIP amount (default: 100)\n * @returns Array of SIP Rolling XIRR entries for each date\n */\nexport function calculateSipRollingXirr(\n  navDataList: NavEntry[][],\n  years: number = 1,\n  allocations: number[],\n  rebalancingEnabled: boolean = false,\n  rebalancingThreshold: number = 5,\n  includeNilTransactions: boolean = false,\n  stepUpEnabled: boolean = false,\n  stepUpPercentage: number = 0,\n  sipAmount: number = 100\n): SipRollingXirrEntry[] {\n  // Reset timing accumulators\n  _xirrTime = 0;\n  _volatilityTime = 0;\n  _transactionTime = 0;\n  \n  // Validate input\n  if (!isValidInput(navDataList)) return [];\n\n  // Prepare data\n  const months = years * 12;\n  const filledNavs = navDataList.map(ensureContinuousDates);\n  const fundDateMaps = filledNavs.map(buildDateMap);\n  const baseDates = getSortedDates(filledNavs[0]);\n  const firstDate = baseDates[0];\n\n  // Calculate XIRR for each date\n  const results = baseDates.flatMap(date =>\n    computeSipXirrForDate(\n      date,\n      fundDateMaps,\n      months,\n      firstDate,\n      allocations,\n      rebalancingEnabled,\n      rebalancingThreshold,\n      includeNilTransactions,\n      stepUpEnabled,\n      stepUpPercentage,\n      sipAmount\n    )\n  );\n  \n  // Log timing breakdown\n  console.log(`[SIP Calc] Transactions: ${(_transactionTime / 1000).toFixed(2)}s | XIRR: ${(_xirrTime / 1000).toFixed(2)}s | Volatility: ${(_volatilityTime / 1000).toFixed(2)}s | Total entries: ${results.length}`);\n  \n  return results;\n}\n\n/**\n * Compute SIP XIRR for a single date\n * OPTIMIZED: Uses pre-computed daily values for volatility instead of nil transactions\n * Falls back to old path when nil transactions are explicitly requested (for tests/modal)\n */\nfunction computeSipXirrForDate(\n  currentDate: Date,\n  fundDateMaps: Map<string, NavEntry>[],\n  months: number,\n  firstDate: Date,\n  allocations: number[],\n  rebalancingEnabled: boolean,\n  rebalancingThreshold: number,\n  includeNilTransactions: boolean,\n  stepUpEnabled: boolean,\n  stepUpPercentage: number,\n  sipAmount: number\n): SipRollingXirrEntry[] {\n  // If nil transactions are explicitly requested, use the old path (slower but includes nil)\n  if (includeNilTransactions) {\n    return computeSipXirrForDateWithNil(\n      currentDate, fundDateMaps, months, firstDate, allocations,\n      rebalancingEnabled, rebalancingThreshold, stepUpEnabled, stepUpPercentage, sipAmount\n    );\n  }\n\n  // OPTIMIZED PATH: Build transactions and compute daily values inline (no nil transactions)\n  const txStart = performance.now();\n  const result = calculateTransactionsForDate(\n    currentDate,\n    fundDateMaps,\n    months,\n    firstDate,\n    allocations,\n    rebalancingEnabled,\n    rebalancingThreshold,\n    stepUpEnabled,\n    stepUpPercentage,\n    sipAmount\n  );\n  _transactionTime += performance.now() - txStart;\n\n  if (!result) return [];\n\n  // Calculate XIRR from transactions (only buy/sell/rebalance) - timed\n  const xirrStart = performance.now();\n  const xirrValue = calculateXirrFromTransactions(result.transactions, currentDate);\n  _xirrTime += performance.now() - xirrStart;\n  if (xirrValue === null) return [];\n\n  // Calculate volatility from pre-computed daily values - timed\n  const volStart = performance.now();\n  const volatility = calculateVolatility(result.dailyValues);\n  _volatilityTime += performance.now() - volStart;\n\n  return [{\n    date: currentDate,\n    xirr: Math.round(xirrValue * 10000) / 10000,\n    transactions: result.transactions, // Already filtered (no nil)\n    volatility: Math.round(volatility * 10000) / 10000\n  }];\n}\n\n/**\n * OLD PATH: Compute with nil transactions included (for tests and modal display)\n */\nfunction computeSipXirrForDateWithNil(\n  currentDate: Date,\n  fundDateMaps: Map<string, NavEntry>[],\n  months: number,\n  firstDate: Date,\n  allocations: number[],\n  rebalancingEnabled: boolean,\n  rebalancingThreshold: number,\n  stepUpEnabled: boolean,\n  stepUpPercentage: number,\n  sipAmount: number\n): SipRollingXirrEntry[] {\n  const txStart = performance.now();\n  const allTransactions = calculateTransactionsForDateWithNil(\n    currentDate,\n    fundDateMaps,\n    months,\n    firstDate,\n    allocations,\n    rebalancingEnabled,\n    rebalancingThreshold,\n    stepUpEnabled,\n    stepUpPercentage,\n    sipAmount\n  );\n  _transactionTime += performance.now() - txStart;\n\n  if (!allTransactions) return [];\n\n  const xirrStart = performance.now();\n  const xirrValue = calculateXirrFromTransactions(allTransactions, currentDate);\n  _xirrTime += performance.now() - xirrStart;\n  if (xirrValue === null) return [];\n\n  // Calculate volatility from transactions (extract daily values from nil transactions)\n  const volStart = performance.now();\n  const dailyValues = extractDailyValuesFromTransactions(allTransactions);\n  const volatility = calculateVolatility(dailyValues);\n  _volatilityTime += performance.now() - volStart;\n\n  return [{\n    date: currentDate,\n    xirr: Math.round(xirrValue * 10000) / 10000,\n    transactions: allTransactions, // Includes nil\n    volatility: Math.round(volatility * 10000) / 10000\n  }];\n}\n\n/**\n * Extract daily values from nil/buy transactions (for old path)\n */\nfunction extractDailyValuesFromTransactions(transactions: Transaction[]): { date: Date; totalValue: number; cashFlow: number }[] {\n  const relevantTransactions = transactions.filter(\n    tx => tx.type === 'nil' || tx.type === 'buy'\n  );\n\n  const transactionsByDate = new Map<string, Transaction[]>();\n  \n  for (const tx of relevantTransactions) {\n    const dateKey = tx.when.toISOString().split('T')[0];\n    if (!transactionsByDate.has(dateKey)) {\n      transactionsByDate.set(dateKey, []);\n    }\n    transactionsByDate.get(dateKey)!.push(tx);\n  }\n\n  const dailyValues: { date: Date; totalValue: number; cashFlow: number }[] = [];\n  \n  for (const [, txs] of transactionsByDate.entries()) {\n    const totalValue = txs.reduce((sum, tx) => sum + tx.currentValue, 0);\n    const cashFlow = txs\n      .filter(tx => tx.type === 'buy')\n      .reduce((sum, tx) => sum + tx.amount, 0);\n    \n    if (totalValue > 0) {\n      dailyValues.push({\n        date: txs[0].when,\n        totalValue,\n        cashFlow\n      });\n    }\n  }\n\n  dailyValues.sort((a, b) => a.date.getTime() - b.date.getTime());\n  \n  return dailyValues;\n}\n\n/**\n * Recalculate transactions for a specific date with nil transactions included\n * Used for on-demand calculation when viewing transaction details in modal\n * \n * @param navDataList - Array of NAV data for each fund\n * @param targetDate - The specific date to recalculate for\n * @param years - Rolling period in years\n * @param allocations - Target allocation percentages for each fund\n * @param rebalancingEnabled - Whether rebalancing was enabled\n * @param rebalancingThreshold - Threshold percentage for rebalancing\n * @param stepUpEnabled - Whether step-up SIP was enabled\n * @param stepUpPercentage - Annual percentage increase for step-up\n * @param sipAmount - Monthly SIP amount\n * @returns Transaction array with nil transactions included, or null if calculation fails\n */\nexport function recalculateTransactionsForDate(\n  navDataList: NavEntry[][],\n  targetDate: Date,\n  years: number,\n  allocations: number[],\n  rebalancingEnabled: boolean,\n  rebalancingThreshold: number,\n  stepUpEnabled: boolean,\n  stepUpPercentage: number,\n  sipAmount: number\n): Transaction[] | null {\n  // Validate input\n  if (!isValidInput(navDataList)) return null;\n\n  // Prepare data\n  const months = years * 12;\n  const filledNavs = navDataList.map(ensureContinuousDates);\n  const fundDateMaps = filledNavs.map(buildDateMap);\n  const baseDates = getSortedDates(filledNavs[0]);\n  const firstDate = baseDates[0];\n\n  // Calculate transactions for the target date with nil included (slower path)\n  const allTransactions = calculateTransactionsForDateWithNil(\n    targetDate,\n    fundDateMaps,\n    months,\n    firstDate,\n    allocations,\n    rebalancingEnabled,\n    rebalancingThreshold,\n    stepUpEnabled,\n    stepUpPercentage,\n    sipAmount\n  );\n\n  return allTransactions;\n}\n"],"names":["areDatesContinuous","navData","sorted","a","b","i","prev","getNthPreviousMonthDate","currentDate","months","date","d","fillMissingNavDates","filled","current","last","sameDay","isValidInput","navDataList","f","ensureContinuousDates","fund","buildDateMap","entry","toDateKey","getSortedDates","generateSipDates","firstDate","sipDates","earliestSipDate","m","sipDate","getInvestmentYear","firstSipDate","yearsDiff","monthsDiff","createBuyTransactions","dateKey","fundDateMaps","allocations","state","stepUpEnabled","stepUpPercentage","sipAmount","totalInvestment","investmentYear","transactions","totalPortfolioValue","fundValues","fundIdx","investmentAmount","units","currentValue","tx","idx","createRebalanceTransactions","loopDate","rebalancingThreshold","portfolioValue","isRebalancingNeeded","rebalanceAmount","rebalanceUnits","cumulativeUnits","threshold","currentAllocation","targetAllocation","createNilTransactions","createFinalSellTransactions","unitsPerFund","sells","amount","calculateTransactionsForDate","rebalancingEnabled","initializeState","result","buildDailyTransactions","sellTransactions","calculateTransactionsForDateWithNil","buildDailyTransactionsWithNil","numFunds","startDate","endDate","dailyValues","isSipDate","cashFlowForDay","processSipDate","sum","dailyValue","computeDailyPortfolioValue","processNilDate","cashFlow","totalValue","buyResult","rebalanceTransactions","newtonRaphsonMethod","newtonRaphson","fp","x0","options","x1","y","yp","tol","maxIter","iter","yph","ymh","yp2h","ym2h","h","hr","verbose","eps","newton","require$$0","MILLIS_PER_DAY","DAYS_IN_YEAR","convert","data","investments","start","end","minAmount","maxAmount","total","deposits","datum","epochDays","investment","xirr","value","rate","A","Y","derivative","guess","xirr_1","calculateXirrFromTransactions","cashflows","aggregateCashflows","calculateXirr","cashflowsMap","currentAmount","dateStr","error","TRADING_DAYS_PER_YEAR","calculateVolatility","dailyReturns","calculateDailyReturns","meanReturn","r","variance","diff","dailyVolatility","totalDays","tradingDays","tradingDaysPerYear","returns","previousEntry","currentEntry","valueChange","marketReturn","_xirrTime","_volatilityTime","_transactionTime","calculateSipRollingXirr","years","includeNilTransactions","filledNavs","baseDates","results","computeSipXirrForDate","computeSipXirrForDateWithNil","txStart","xirrStart","xirrValue","volStart","volatility","allTransactions","extractDailyValuesFromTransactions","relevantTransactions","transactionsByDate","txs","recalculateTransactionsForDate","targetDate"],"mappings":"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","x_google_ignoreList":[8,9]}