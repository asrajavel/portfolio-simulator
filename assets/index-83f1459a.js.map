{"version":3,"file":"index-83f1459a.js","sources":["../src/utils/date/dateUtils.ts","../src/utils/data/fillMissingNavDates.ts","../src/utils/calculations/sipRollingXirr/core/helpers.ts","../src/utils/calculations/sipRollingXirr/transactions/buy.ts","../src/utils/calculations/sipRollingXirr/transactions/rebalance.ts","../src/utils/calculations/sipRollingXirr/transactions/nil.ts","../src/utils/calculations/sipRollingXirr/transactions/sell.ts","../src/utils/calculations/sipRollingXirr/core/transactionBuilder.ts","../node_modules/newton-raphson-method/index.js","../node_modules/xirr/xirr.js","../src/utils/calculations/sipRollingXirr/core/xirrCalculator.ts","../src/utils/calculations/sipRollingXirr/volatility/sipPortfolioValue.ts","../src/utils/calculations/sipRollingXirr/volatility/volatilityCalculator.ts","../src/utils/calculations/sipRollingXirr/volatility/index.ts","../src/utils/calculations/sipRollingXirr/index.ts"],"sourcesContent":["// Date utility functions for NAV and lump sum rolling XIRR calculations\nimport { NavEntry } from '../../types/navData';\nimport { MILLISECONDS_PER_DAY } from '../../constants';\n\nexport function areDatesContinuous(navData: NavEntry[]): boolean {\n  if (navData.length < 2) return true;\n  const sorted = [...navData].sort((a, b) => a.date.getTime() - b.date.getTime());\n  for (let i = 1; i < sorted.length; i++) {\n    const prev = sorted[i - 1].date;\n    const curr = sorted[i].date;\n    const diff = (curr.getTime() - prev.getTime()) / MILLISECONDS_PER_DAY;\n    if (diff !== 1) return false;\n  }\n  return true;\n}\n\n// Get the date N months before a given date, handling month-end edge cases\nexport function getNthPreviousMonthDate(currentDate: Date, months: number): Date {\n  const date = new Date(currentDate);\n  const d = date.getDate();\n  date.setMonth(date.getMonth() - months);\n  // Handle month-end edge case (e.g., March 31 -> Feb 28/29)\n  if (date.getDate() < d) {\n    date.setDate(0); // Go to last day of previous month\n  }\n  return date;\n} ","import { NavEntry } from '../../types/navData';\n\nexport function fillMissingNavDates(navData: NavEntry[]): NavEntry[] {\n  if (navData.length === 0) return [];\n\n  // Sort ascending (oldest first)\n  const sorted = [...navData].sort((a, b) => a.date.getTime() - b.date.getTime());\n  const filled: NavEntry[] = [];\n  let i = 0;\n  let current = new Date(sorted[0].date);\n  const last = sorted[sorted.length - 1].date;\n\n  while (current <= last) {\n    if (i < sorted.length && sameDay(current, sorted[i].date)) {\n      filled.push({ date: new Date(current), nav: sorted[i].nav });\n      i++;\n    } else {\n      // Use the next available NAV (forward fill)\n      filled.push({ date: new Date(current), nav: sorted[i].nav });\n    }\n    current.setDate(current.getDate() + 1);\n  }\n  return filled;\n}\n\nfunction sameDay(a: Date, b: Date) {\n  return a.getFullYear() === b.getFullYear() &&\n    a.getMonth() === b.getMonth() &&\n    a.getDate() === b.getDate();\n} ","import { NavEntry } from '../../../../types/navData';\nimport { areDatesContinuous, getNthPreviousMonthDate } from '../../../date/dateUtils';\nimport { fillMissingNavDates } from '../../../data/fillMissingNavDates';\n\nexport function isValidInput(navDataList: NavEntry[][]): boolean {\n  return navDataList.length > 0 && !navDataList.some(f => f.length < 2);\n}\n\nexport function ensureContinuousDates(fund: NavEntry[]): NavEntry[] {\n  return areDatesContinuous(fund) ? fund : fillMissingNavDates(fund);\n}\n\nexport function buildDateMap(fund: NavEntry[]): Map<string, NavEntry> {\n  return new Map(fund.map(entry => [toDateKey(entry.date), entry]));\n}\n\nexport function getSortedDates(fund: NavEntry[]): Date[] {\n  return [...fund]\n    .sort((a, b) => a.date.getTime() - b.date.getTime())\n    .map(entry => entry.date);\n}\n\nexport function toDateKey(date: Date): string {\n  return date.toISOString().split('T')[0];\n}\n\n// ────────────── SIP Date Generation ────────────── //\n\nexport interface SipDatesResult {\n  dateSet: Set<string>;\n  earliestDate: Date | null;\n}\n\nexport function generateSipDates(\n  currentDate: Date,\n  months: number,\n  firstDate: Date\n): SipDatesResult {\n  const sipDates = new Set<string>();\n  let earliestSipDate: Date | null = null;\n\n  for (let m = months; m >= 1; m--) {\n    const sipDate = getNthPreviousMonthDate(currentDate, m);\n    if (sipDate < firstDate) {\n      return { dateSet: sipDates, earliestDate: null };\n    }\n\n    sipDates.add(toDateKey(sipDate));\n    if (!earliestSipDate || sipDate < earliestSipDate) {\n      earliestSipDate = sipDate;\n    }\n  }\n\n  return { dateSet: sipDates, earliestDate: earliestSipDate };\n}\n\n/**\n * Calculate which investment year a given date falls into, starting from the first SIP date\n * Used for step-up SIP calculations where investment amount increases yearly\n * \n * @param currentDate - The date to check\n * @param firstSipDate - The first SIP date (year 1 starts from this date)\n * @returns The investment year (1-based: 1 for first year, 2 for second year, etc.)\n */\nexport function getInvestmentYear(currentDate: Date, firstSipDate: Date): number {\n  const yearsDiff = currentDate.getFullYear() - firstSipDate.getFullYear();\n  const monthsDiff = currentDate.getMonth() - firstSipDate.getMonth();\n  const totalYears = yearsDiff + (monthsDiff >= 0 ? 0 : -1);\n  return totalYears + 1; // Return 1-based year\n}\n\n","import { NavEntry } from '../../../../types/navData';\nimport { Transaction } from '../types';\nimport { getInvestmentYear } from '../core/helpers';\n\ninterface BuyTransactionsResult {\n  transactions: Transaction[];\n  portfolioValue: number;\n}\n\ninterface TransactionState {\n  cumulativeUnits: number[];\n  unitsPerFund: number[];\n}\n\n/**\n * Create buy transactions for a SIP date\n */\nexport function createBuyTransactions(\n  dateKey: string,\n  fundDateMaps: Map<string, NavEntry>[],\n  allocations: number[],\n  state: TransactionState,\n  currentDate: Date,\n  firstSipDate: Date,\n  stepUpEnabled: boolean,\n  stepUpPercentage: number,\n  sipAmount: number\n): BuyTransactionsResult | null {\n  // Calculate investment with step-up if enabled\n  let totalInvestment = sipAmount;\n  \n  if (stepUpEnabled && stepUpPercentage > 0) {\n    const investmentYear = getInvestmentYear(currentDate, firstSipDate);\n    // Apply compound step-up: Year 1 = sipAmount, Year 2 = sipAmount * (1 + r), Year 3 = sipAmount * (1 + r)^2, etc.\n    totalInvestment = sipAmount * Math.pow(1 + stepUpPercentage / 100, investmentYear - 1);\n  }\n  const transactions: Transaction[] = [];\n  let totalPortfolioValue = 0;\n  const fundValues: number[] = [];\n\n  for (let fundIdx = 0; fundIdx < fundDateMaps.length; fundIdx++) {\n    const entry = fundDateMaps[fundIdx].get(dateKey);\n    if (!entry) return null;\n\n    const investmentAmount = totalInvestment * (allocations[fundIdx] / 100);\n    const units = investmentAmount / entry.nav;\n\n    state.cumulativeUnits[fundIdx] += units;\n    state.unitsPerFund[fundIdx] += units;\n\n    const currentValue = state.cumulativeUnits[fundIdx] * entry.nav;\n    fundValues.push(currentValue);\n    totalPortfolioValue += currentValue;\n\n    transactions.push({\n      fundIdx,\n      nav: entry.nav,\n      when: entry.date,\n      units,\n      amount: -investmentAmount,\n      type: 'buy',\n      cumulativeUnits: state.cumulativeUnits[fundIdx],\n      currentValue,\n      allocationPercentage: 0,\n    });\n  }\n\n  transactions.forEach((tx, idx) => {\n    tx.allocationPercentage = totalPortfolioValue > 0 ? (fundValues[idx] / totalPortfolioValue) * 100 : 0;\n  });\n\n  return { transactions, portfolioValue: totalPortfolioValue };\n}\n\n","import { NavEntry } from '../../../../types/navData';\nimport { Transaction } from '../types';\n\ninterface TransactionState {\n  cumulativeUnits: number[];\n  unitsPerFund: number[];\n}\n\n/**\n * Create rebalance transactions if needed\n */\nexport function createRebalanceTransactions(\n  dateKey: string,\n  loopDate: Date,\n  fundDateMaps: Map<string, NavEntry>[],\n  allocations: number[],\n  rebalancingThreshold: number,\n  portfolioValue: number,\n  state: TransactionState\n): Transaction[] | null {\n  if (!isRebalancingNeeded(state.cumulativeUnits, fundDateMaps, dateKey, allocations, rebalancingThreshold, portfolioValue)) {\n    return [];\n  }\n\n  const transactions: Transaction[] = [];\n\n  for (let fundIdx = 0; fundIdx < fundDateMaps.length; fundIdx++) {\n    const entry = fundDateMaps[fundIdx].get(dateKey);\n    if (!entry) return null;\n\n    const currentValue = state.cumulativeUnits[fundIdx] * entry.nav;\n    const targetValue = portfolioValue * (allocations[fundIdx] / 100);\n    const rebalanceAmount = targetValue - currentValue;\n\n    if (Math.abs(rebalanceAmount) > 0.01) {\n      const rebalanceUnits = rebalanceAmount / entry.nav;\n\n      state.cumulativeUnits[fundIdx] += rebalanceUnits;\n      state.unitsPerFund[fundIdx] += rebalanceUnits;\n\n      transactions.push({\n        fundIdx,\n        when: new Date(loopDate),\n        nav: entry.nav,\n        units: rebalanceUnits,\n        amount: -rebalanceAmount,\n        type: 'rebalance',\n        cumulativeUnits: state.cumulativeUnits[fundIdx],\n        currentValue: state.cumulativeUnits[fundIdx] * entry.nav,\n        allocationPercentage: allocations[fundIdx],\n      });\n    }\n  }\n\n  return transactions;\n}\n\nfunction isRebalancingNeeded(\n  cumulativeUnits: number[],\n  fundDateMaps: Map<string, NavEntry>[],\n  dateKey: string,\n  allocations: number[],\n  threshold: number,\n  portfolioValue: number\n): boolean {\n  for (let fundIdx = 0; fundIdx < fundDateMaps.length; fundIdx++) {\n    const entry = fundDateMaps[fundIdx].get(dateKey);\n    if (!entry) continue;\n\n    const currentValue = cumulativeUnits[fundIdx] * entry.nav;\n    const currentAllocation = (currentValue / portfolioValue) * 100;\n    const targetAllocation = allocations[fundIdx];\n\n    if (Math.abs(currentAllocation - targetAllocation) > threshold) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n","import { NavEntry } from '../../../../types/navData';\nimport { Transaction } from '../types';\n\ninterface TransactionState {\n  cumulativeUnits: number[];\n}\n\n/**\n * Create nil transactions for non-SIP dates (showing current holdings)\n */\nexport function createNilTransactions(\n  dateKey: string,\n  fundDateMaps: Map<string, NavEntry>[],\n  state: Pick<TransactionState, 'cumulativeUnits'>\n): Transaction[] | null {\n  const transactions: Transaction[] = [];\n  let totalPortfolioValue = 0;\n\n  for (let fundIdx = 0; fundIdx < fundDateMaps.length; fundIdx++) {\n    const entry = fundDateMaps[fundIdx].get(dateKey);\n    if (!entry) return null;\n\n    const currentValue = state.cumulativeUnits[fundIdx] * entry.nav;\n    totalPortfolioValue += currentValue;\n\n    transactions.push({\n      fundIdx,\n      when: entry.date,\n      nav: entry.nav,\n      units: 0,\n      amount: 0,\n      type: 'nil',\n      cumulativeUnits: state.cumulativeUnits[fundIdx],\n      currentValue,\n      allocationPercentage: 0,\n    });\n  }\n\n  transactions.forEach(tx => {\n    tx.allocationPercentage = totalPortfolioValue > 0 ? (tx.currentValue / totalPortfolioValue) * 100 : 0;\n  });\n\n  return transactions;\n}\n\n","import { NavEntry } from '../../../../types/navData';\nimport { Transaction } from '../types';\nimport { toDateKey } from '../core/helpers';\n\n/**\n * Create final sell transactions at the end date\n */\nexport function createFinalSellTransactions(\n  currentDate: Date,\n  fundDateMaps: Map<string, NavEntry>[],\n  unitsPerFund: number[]\n): Transaction[] | null {\n  const dateKey = toDateKey(currentDate);\n  const sells: Transaction[] = [];\n\n  for (let fundIdx = 0; fundIdx < fundDateMaps.length; fundIdx++) {\n    const entry = fundDateMaps[fundIdx].get(dateKey);\n    if (!entry) return null;\n\n    const units = unitsPerFund[fundIdx];\n    const amount = units * entry.nav;\n\n    sells.push({\n      fundIdx,\n      nav: entry.nav,\n      when: entry.date,\n      units,\n      amount,\n      type: 'sell',\n      cumulativeUnits: units,\n      currentValue: units * entry.nav,\n    });\n  }\n\n  return sells;\n}\n\n","import { NavEntry } from '../../../../types/navData';\nimport { Transaction } from '../types';\nimport { toDateKey, generateSipDates } from './helpers';\nimport { createBuyTransactions } from '../transactions/buy';\nimport { createRebalanceTransactions } from '../transactions/rebalance';\nimport { createNilTransactions } from '../transactions/nil';\nimport { createFinalSellTransactions } from '../transactions/sell';\n\n/**\n * Calculate all transactions for a given date, including buy/rebalance/nil transactions\n * and the final sell transaction at the end date\n */\nexport function calculateTransactionsForDate(\n  currentDate: Date,\n  fundDateMaps: Map<string, NavEntry>[],\n  months: number,\n  firstDate: Date,\n  allocations: number[],\n  rebalancingEnabled: boolean,\n  rebalancingThreshold: number,\n  stepUpEnabled: boolean,\n  stepUpPercentage: number,\n  sipAmount: number\n): Transaction[] | null {\n  const sipDates = generateSipDates(currentDate, months, firstDate);\n  if (!sipDates.earliestDate) {\n    return null;\n  }\n\n  const state = initializeState(fundDateMaps.length);\n  const transactions = buildDailyTransactions(\n    sipDates.earliestDate,\n    currentDate,\n    sipDates.dateSet,\n    fundDateMaps,\n    allocations,\n    rebalancingEnabled,\n    rebalancingThreshold,\n    stepUpEnabled,\n    stepUpPercentage,\n    sipAmount,\n    state\n  );\n\n  if (!transactions) return null;\n\n  // Add final selling transactions at current date\n  const sellTransactions = createFinalSellTransactions(currentDate, fundDateMaps, state.unitsPerFund);\n  if (!sellTransactions) return null;\n\n  return [...transactions, ...sellTransactions];\n}\n\n// ────────────── Private Helpers ────────────── //\n\ninterface TransactionState {\n  unitsPerFund: number[];\n  cumulativeUnits: number[];\n}\n\nfunction initializeState(numFunds: number): TransactionState {\n  return {\n    unitsPerFund: new Array(numFunds).fill(0),\n    cumulativeUnits: new Array(numFunds).fill(0),\n  };\n}\n\nfunction buildDailyTransactions(\n  startDate: Date,\n  endDate: Date,\n  sipDates: Set<string>,\n  fundDateMaps: Map<string, NavEntry>[],\n  allocations: number[],\n  rebalancingEnabled: boolean,\n  rebalancingThreshold: number,\n  stepUpEnabled: boolean,\n  stepUpPercentage: number,\n  sipAmount: number,\n  state: TransactionState\n): Transaction[] | null {\n  const transactions: Transaction[] = [];\n  const loopDate = new Date(startDate);\n  const firstSipDate = new Date(startDate); // Store first SIP date for step-up calculation\n\n  while (loopDate < endDate) {\n    const dateKey = toDateKey(loopDate);\n    const isSipDate = sipDates.has(dateKey);\n\n    const result = isSipDate\n      ? processSipDate(dateKey, loopDate, fundDateMaps, allocations, rebalancingEnabled, rebalancingThreshold, firstSipDate, stepUpEnabled, stepUpPercentage, sipAmount, state)\n      : processNilDate(dateKey, fundDateMaps, state);\n\n    if (!result) return null;\n    transactions.push(...result);\n\n    loopDate.setDate(loopDate.getDate() + 1);\n  }\n\n  return transactions;\n}\n\nfunction processSipDate(\n  dateKey: string,\n  loopDate: Date,\n  fundDateMaps: Map<string, NavEntry>[],\n  allocations: number[],\n  rebalancingEnabled: boolean,\n  rebalancingThreshold: number,\n  firstSipDate: Date,\n  stepUpEnabled: boolean,\n  stepUpPercentage: number,\n  sipAmount: number,\n  state: TransactionState\n): Transaction[] | null {\n  const buyResult = createBuyTransactions(dateKey, fundDateMaps, allocations, state, loopDate, firstSipDate, stepUpEnabled, stepUpPercentage, sipAmount);\n  if (!buyResult) return null;\n\n  const rebalanceTransactions = rebalancingEnabled\n    ? createRebalanceTransactions(dateKey, loopDate, fundDateMaps, allocations, rebalancingThreshold, buyResult.portfolioValue, state)\n    : [];\n\n  if (rebalanceTransactions === null) return null;\n\n  return [...buyResult.transactions, ...rebalanceTransactions];\n}\n\nfunction processNilDate(\n  dateKey: string,\n  fundDateMaps: Map<string, NavEntry>[],\n  state: TransactionState\n): Transaction[] | null {\n  return createNilTransactions(dateKey, fundDateMaps, state);\n}\n\n","'use strict';\n\nmodule.exports = newtonRaphson;\n\nfunction newtonRaphson (f, fp, x0, options) {\n  var x1, y, yp, tol, maxIter, iter, yph, ymh, yp2h, ym2h, h, hr, verbose, eps;\n\n  // Iterpret variadic forms:\n  if (typeof fp !== 'function') {\n    options = x0;\n    x0 = fp;\n    fp = null;\n  }\n\n  options = options || {};\n  tol = options.tolerance === undefined ? 1e-7 : options.tolerance;\n  eps = options.epsilon === undefined ? 2.220446049250313e-16 : options.epsilon;\n  maxIter = options.maxIterations === undefined ? 20 : options.maxIterations;\n  h = options.h === undefined ? 1e-4 : options.h;\n  verbose = options.verbose === undefined ? false : options.verbose;\n  hr = 1 / h;\n\n  iter = 0;\n  while (iter++ < maxIter) {\n    // Compute the value of the function:\n    y = f(x0);\n\n    if (fp) {\n      yp = fp(x0);\n    } else {\n      // Needs numerical derivatives:\n      yph = f(x0 + h);\n      ymh = f(x0 - h);\n      yp2h = f(x0 + 2 * h);\n      ym2h = f(x0 - 2 * h);\n\n      yp = ((ym2h - yp2h) + 8 * (yph - ymh)) * hr / 12;\n    }\n\n    // Check for badly conditioned update (extremely small first deriv relative to function):\n    if (Math.abs(yp) <= eps * Math.abs(y)) {\n      if (verbose) {\n        console.log('Newton-Raphson: failed to converged due to nearly zero first derivative');\n      }\n      return false;\n    }\n\n    // Update the guess:\n    x1 = x0 - y / yp;\n\n    // Check for convergence:\n    if (Math.abs(x1 - x0) <= tol * Math.abs(x1)) {\n      if (verbose) {\n        console.log('Newton-Raphson: converged to x = ' + x1 + ' after ' + iter + ' iterations');\n      }\n      return x1;\n    }\n\n    // Transfer update to the new guess:\n    x0 = x1;\n  }\n\n  if (verbose) {\n    console.log('Newton-Raphson: Maximum iterations reached (' + maxIter + ')');\n  }\n\n  return false;\n}\n","'use strict';\n\nvar newton = require('newton-raphson-method');\n\nvar MILLIS_PER_DAY = 1000*60*60*24;\nvar DAYS_IN_YEAR = 365;\n\nfunction convert(data) {\n    if (!data || !data.length || !data.forEach || data.length < 2) {\n        throw new Error('Argument is not an array with length of 2 or more.');\n    }\n\n    var investments = [];\n    var start = Math.floor(data[0].when/MILLIS_PER_DAY);\n    var end = start;\n    var minAmount = Number.POSITIVE_INFINITY;\n    var maxAmount = Number.NEGATIVE_INFINITY;\n    var total = 0;\n    var deposits = 0;\n    data.forEach(function(datum) {\n        total += datum.amount;\n        if (datum.amount < 0) {\n            deposits += -datum.amount;\n        }\n        var epochDays = Math.floor(datum.when/MILLIS_PER_DAY);\n        start = Math.min(start, epochDays);\n        end = Math.max(end, epochDays);\n        minAmount = Math.min(minAmount, datum.amount);\n        maxAmount = Math.max(maxAmount, datum.amount);\n        investments.push({\n            amount: datum.amount,\n            epochDays: epochDays\n        });\n    });\n    if (start === end) {\n        throw new Error('Transactions must not all be on the same day.');\n    }\n    if (minAmount >= 0) {\n        throw new Error('Transactions must not all be nonnegative.');\n    }\n    if (maxAmount < 0) {\n        throw new Error('Transactions must not all be negative.');\n    }\n    investments.forEach(function(investment) {\n        // Number of years (including fraction) this item applies\n        investment.years = (end - investment.epochDays) / DAYS_IN_YEAR;\n    });\n    return {\n        total: total,\n        deposits: deposits,\n        days: end - start,\n        investments: investments,\n        maxAmount: maxAmount\n    };\n}\n\nfunction xirr(transactions, options) {\n    var data = convert(transactions);\n    if (data.maxAmount === 0) {\n        return -1;\n    }\n    var investments = data.investments;\n    var value = function(rate) {\n        return investments.reduce(function(sum, investment) {\n            // Make the vars more Math-y, makes the derivative easier to see\n            var A = investment.amount;\n            var Y = investment.years;\n            if (-1 < rate) {\n                return sum + A * Math.pow(1+rate, Y);\n            } else if (rate < -1) {\n                // Extend the function into the range where the rate is less\n                // than -100%.  Even though this does not make practical sense,\n                // it allows the algorithm to converge in the cases where the\n                // candidate values enter this range\n\n                // We cannot use the same formula as before, since the base of\n                // the exponent (1+rate) is negative, this yields imaginary\n                // values for fractional years.\n                // E.g. if rate=-1.5 and years=.5, it would be (-.5)^.5,\n                // i.e. the square root of negative one half.\n\n                // Ensure the values are always negative so there can never\n                // be a zero (as long as some amount is non-zero).\n                // This formula also ensures that the derivative is positive\n                // (when rate < -1) so that Newton's method is encouraged to \n                // move the candidate values towards the proper range\n\n                return sum - Math.abs(A) * Math.pow(-1-rate, Y);\n            } else if (Y === 0) {\n                return sum + A;  // Treat 0^0 as 1\n            } else {\n                return sum;\n            }\n        }, 0);\n    };\n    var derivative = function(rate) {\n        return investments.reduce(function(sum, investment) {\n            // Make the vars more Math-y, makes the derivative easier to see\n            var A = investment.amount;\n            var Y = investment.years;\n            if (Y === 0) {\n                return sum;\n            } else if (-1 < rate) {\n                return sum + A * Y * Math.pow(1+rate, Y-1);\n            } else if (rate < -1) {\n                return sum + Math.abs(A) * Y * Math.pow(-1-rate, Y-1);\n            } else {\n                return sum;\n            }\n        }, 0);\n    };\n    var guess = options ? options.guess : undefined;\n    if (guess && isNaN(guess)) {\n        throw new Error(\"option.guess must be a number.\");\n    }\n    if (!guess) {\n        guess = (data.total / data.deposits) / (data.days/DAYS_IN_YEAR);\n    }\n    var rate = newton(value, derivative, guess, options);\n    if (rate === false) {  // truthiness strikes again, !rate is true when rate is zero\n        throw new Error(\"Newton-Raphson algorithm failed to converge.\");\n    }\n    return rate;\n}\n\nmodule.exports = xirr;\n","import xirr from 'xirr';\nimport { Transaction } from '../types';\nimport { toDateKey } from './helpers';\n\n/**\n * Calculate XIRR from a list of transactions\n * \n * @param transactions - Array of transactions (buy, sell, rebalance, nil)\n * @param currentDate - Current date for error logging\n * @returns XIRR value or null if calculation fails\n */\nexport function calculateXirrFromTransactions(\n  transactions: Transaction[],\n  currentDate: Date\n): number | null {\n  const cashflows = aggregateCashflows(transactions);\n  return calculateXirr(cashflows, currentDate);\n}\n\n// ────────────── Private Helpers ────────────── //\n\nfunction aggregateCashflows(transactions: Transaction[]): Array<{ amount: number; when: Date }> {\n  const cashflowsMap = new Map<string, number>();\n\n  for (const tx of transactions) {\n    if (tx.type === 'nil') continue; // Skip nil transactions (amount: 0, just overhead)\n\n    const dateKey = toDateKey(tx.when);\n    const currentAmount = cashflowsMap.get(dateKey) || 0;\n    cashflowsMap.set(dateKey, currentAmount + tx.amount);\n  }\n\n  const cashflows = Array.from(cashflowsMap.entries()).map(([dateStr, amount]) => ({\n    amount,\n    when: new Date(dateStr),\n  }));\n\n  cashflows.sort((a, b) => a.when.getTime() - b.when.getTime());\n\n  return cashflows;\n}\n\nfunction calculateXirr(cashflows: Array<{ amount: number; when: Date }>, currentDate: Date): number | null {\n  try {\n    return xirr(cashflows);\n  } catch (error) {\n    console.warn(`XIRR calculation failed for date ${currentDate.toISOString()}:`, error);\n    return null;\n  }\n}\n\n","import { Transaction } from '../types';\n\nexport interface DailySipPortfolioValue {\n  date: Date;\n  totalValue: number;\n  cashFlow: number; // Net cash flow on this day (negative for buy, positive for sell)\n}\n\n/**\n * Calculate daily portfolio values from transactions\n * Uses total portfolio value (sum of currentValue across all funds)\n * Includes nil and buy transactions to capture market movements on buy days\n * Tracks cash flows for accurate return calculation\n * \n * @param transactions - All transactions\n */\nexport function calculateDailySipPortfolioValue(\n  transactions: Transaction[]\n): DailySipPortfolioValue[] {\n  // Include nil and buy transactions (exclude sell and rebalance)\n  const relevantTransactions = transactions.filter(\n    tx => tx.type === 'nil' || tx.type === 'buy'\n  );\n\n  if (relevantTransactions.length === 0) {\n    return [];\n  }\n\n  // Group transactions by date\n  const transactionsByDate = groupTransactionsByDate(relevantTransactions);\n\n  // Calculate total value and cash flow for each date\n  const dailyValues: DailySipPortfolioValue[] = [];\n\n  for (const [dateKey, txs] of transactionsByDate.entries()) {\n    const totalValue = calculateTotalValue(txs);\n    const cashFlow = calculateCashFlow(txs);\n    \n    if (totalValue > 0) {\n      dailyValues.push({\n        date: txs[0].when,\n        totalValue,\n        cashFlow\n      });\n    }\n  }\n\n  // Sort by date\n  dailyValues.sort((a, b) => a.date.getTime() - b.date.getTime());\n\n  return dailyValues;\n}\n\n/**\n * Group transactions by date key\n */\nfunction groupTransactionsByDate(\n  transactions: Transaction[]\n): Map<string, Transaction[]> {\n  const map = new Map<string, Transaction[]>();\n  \n  for (const tx of transactions) {\n    const dateKey = tx.when.toISOString().split('T')[0];\n    if (!map.has(dateKey)) {\n      map.set(dateKey, []);\n    }\n    map.get(dateKey)!.push(tx);\n  }\n  \n  return map;\n}\n\n/**\n * Calculate total portfolio value from transactions on a single date\n */\nfunction calculateTotalValue(transactions: Transaction[]): number {\n  return transactions.reduce((sum, tx) => sum + tx.currentValue, 0);\n}\n\n/**\n * Calculate net cash flow from transactions on a single date\n */\nfunction calculateCashFlow(transactions: Transaction[]): number {\n  return transactions\n    .filter(tx => tx.type === 'buy')\n    .reduce((sum, tx) => sum + tx.amount, 0); // amount is negative for buy\n}\n\n","import { DailySipPortfolioValue } from './sipPortfolioValue';\n\nconst TRADING_DAYS_PER_YEAR = 252;\n\n/**\n * Calculate portfolio volatility from daily portfolio values\n * Returns annualized volatility as a percentage\n * \n * Automatically excludes forward-filled weekends/holidays (where value didn't change)\n * and adjusts annualization based on actual trading days in the data\n */\nexport function calculateVolatility(\n  dailyValues: DailySipPortfolioValue[]\n): number {\n  // Need at least 2 data points to calculate volatility\n  if (dailyValues.length < 2) {\n    return 0;\n  }\n\n  // Calculate daily returns (excludes forward-filled non-trading days)\n  const dailyReturns = calculateDailyReturns(dailyValues);\n\n  // Need at least 2 returns to calculate volatility\n  if (dailyReturns.length < 2) {\n    return 0;\n  }\n\n  // Calculate mean return\n  const meanReturn = dailyReturns.reduce((sum, r) => sum + r, 0) / dailyReturns.length;\n\n  // Calculate variance\n  const variance = dailyReturns.reduce((sum, r) => {\n    const diff = r - meanReturn;\n    return sum + (diff * diff);\n  }, 0) / dailyReturns.length;\n\n  // Calculate standard deviation (daily volatility)\n  const dailyVolatility = Math.sqrt(variance);\n\n  // Calculate trading days per year based on actual data\n  // If we have 365 days but only 252 returns (69% ratio), annualize accordingly\n  const totalDays = dailyValues.length - 1; // Subtract 1 since we calculate returns between days\n  const tradingDays = dailyReturns.length;\n  const tradingDaysPerYear = totalDays > 0 \n    ? Math.round((tradingDays / totalDays) * 365)\n    : TRADING_DAYS_PER_YEAR; // Default to 252 if calculation fails\n\n  // Annualize volatility using calculated trading days\n  const annualizedVolatility = dailyVolatility * Math.sqrt(tradingDaysPerYear);\n\n  const volatilityPercent = (annualizedVolatility * 100) || 0;\n\n  return volatilityPercent;\n}\n\n/**\n * Calculate daily returns from portfolio values\n * Daily Return = (Today's Value - Yesterday's Value + Cash Flow) / Yesterday's Value\n * \n * Adjusts for cash flows to get true market returns:\n * - On buy days: valueChange + (-100) removes the 100 investment from the increase\n * - On nil days: valueChange + 0 = no adjustment needed\n * - This isolates the market movement from cash flow effects\n * \n * Skips forward-filled days (weekends/holidays) where:\n * - Portfolio value didn't change AND\n * - No cash flow occurred (no actual transaction)\n * This prevents artificially low volatility from zero returns on non-trading days\n */\nfunction calculateDailyReturns(dailyValues: DailySipPortfolioValue[]): number[] {\n  const returns: number[] = [];\n\n  // Calculate returns from consecutive days (array is already sorted and continuous)\n  for (let i = 1; i < dailyValues.length; i++) {\n    const previousEntry = dailyValues[i - 1];\n    const currentEntry = dailyValues[i];\n\n    if (previousEntry.totalValue > 0) {\n      const valueChange = currentEntry.totalValue - previousEntry.totalValue;\n      \n      // Skip forward-filled days (weekends/holidays) where value didn't change and no cash flow\n      // This prevents artificially low volatility from zero returns on non-trading days\n      if (valueChange === 0 && currentEntry.cashFlow === 0) {\n        continue; // Skip this day - it's a forward-filled non-trading day\n      }\n      \n      // Adjust for cash flow to get true market return\n      // currentEntry.cashFlow is negative for buy (money out)\n      // We ADD cashFlow to remove investment effect from value change\n      const marketReturn = (valueChange + currentEntry.cashFlow) / previousEntry.totalValue;\n      \n      returns.push(marketReturn);\n    }\n  }\n\n  return returns;\n}\n\n","import { Transaction } from '../types';\nimport { calculateDailySipPortfolioValue } from './sipPortfolioValue';\nimport { calculateVolatility } from './volatilityCalculator';\n\nexport type { DailySipPortfolioValue } from './sipPortfolioValue';\n\n/**\n * Calculate portfolio volatility for a set of transactions\n * \n * @param transactions - All transactions from SIP start to current date\n * @returns Annualized volatility percentage (0 if insufficient data)\n */\nexport function calculateVolatilityForEntry(\n  transactions: Transaction[]\n): number {\n  // Calculate daily portfolio values using actual drifting allocations\n  const dailyValues = calculateDailySipPortfolioValue(transactions);\n\n  // Calculate volatility from portfolio values\n  return calculateVolatility(dailyValues);\n}\n\n","import { NavEntry } from '../../../types/navData';\nimport { SipRollingXirrEntry, Transaction } from './types';\nimport { isValidInput, ensureContinuousDates, buildDateMap, getSortedDates } from './core/helpers';\nimport { calculateTransactionsForDate } from './core/transactionBuilder';\nimport { calculateXirrFromTransactions } from './core/xirrCalculator';\nimport { calculateVolatilityForEntry } from './volatility';\n\n// Re-export types for backward compatibility\nexport type { SipRollingXirrEntry, Transaction } from './types';\n\n/**\n * Calculate SIP Rolling XIRR for given NAV data\n * \n * @param navDataList - Array of NAV data for each fund\n * @param years - Rolling period in years (default: 1)\n * @param allocations - Target allocation percentages for each fund\n * @param rebalancingEnabled - Whether to enable portfolio rebalancing (default: false)\n * @param rebalancingThreshold - Threshold percentage for triggering rebalancing (default: 5)\n * @param includeNilTransactions - Whether to include nil transactions in result (default: false, set true for tests)\n * @param stepUpEnabled - Whether to enable step-up SIP (default: false)\n * @param stepUpPercentage - Annual percentage increase for step-up SIP (default: 0)\n * @param sipAmount - Monthly SIP amount (default: 100)\n * @returns Array of SIP Rolling XIRR entries for each date\n */\nexport function calculateSipRollingXirr(\n  navDataList: NavEntry[][],\n  years: number = 1,\n  allocations: number[],\n  rebalancingEnabled: boolean = false,\n  rebalancingThreshold: number = 5,\n  includeNilTransactions: boolean = false,\n  stepUpEnabled: boolean = false,\n  stepUpPercentage: number = 0,\n  sipAmount: number = 100\n): SipRollingXirrEntry[] {\n  // Validate input\n  if (!isValidInput(navDataList)) return [];\n\n  // Prepare data\n  const months = years * 12;\n  const filledNavs = navDataList.map(ensureContinuousDates);\n  const fundDateMaps = filledNavs.map(buildDateMap);\n  const baseDates = getSortedDates(filledNavs[0]);\n  const firstDate = baseDates[0];\n\n  // Calculate XIRR for each date\n  return baseDates.flatMap(date =>\n    computeSipXirrForDate(\n      date,\n      fundDateMaps,\n      months,\n      firstDate,\n      allocations,\n      rebalancingEnabled,\n      rebalancingThreshold,\n      includeNilTransactions,\n      stepUpEnabled,\n      stepUpPercentage,\n      sipAmount\n    )\n  );\n}\n\n/**\n * Compute SIP XIRR for a single date\n * This is the orchestration function that coordinates transaction building and XIRR calculation\n */\nfunction computeSipXirrForDate(\n  currentDate: Date,\n  fundDateMaps: Map<string, NavEntry>[],\n  months: number,\n  firstDate: Date,\n  allocations: number[],\n  rebalancingEnabled: boolean,\n  rebalancingThreshold: number,\n  includeNilTransactions: boolean,\n  stepUpEnabled: boolean,\n  stepUpPercentage: number,\n  sipAmount: number\n): SipRollingXirrEntry[] {\n  // Build all transactions (buy, sell, rebalance, nil)\n  const allTransactions = calculateTransactionsForDate(\n    currentDate,\n    fundDateMaps,\n    months,\n    firstDate,\n    allocations,\n    rebalancingEnabled,\n    rebalancingThreshold,\n    stepUpEnabled,\n    stepUpPercentage,\n    sipAmount\n  );\n\n  if (!allTransactions) return [];\n\n  // Calculate XIRR from transactions\n  const xirrValue = calculateXirrFromTransactions(allTransactions, currentDate);\n  if (xirrValue === null) return [];\n\n  // Calculate volatility from all transactions (includes nil for accurate daily tracking)\n  const volatility = calculateVolatilityForEntry(allTransactions);\n\n  // Filter nil transactions if not needed (for memory efficiency)\n  const transactionsToReturn = includeNilTransactions\n    ? allTransactions\n    : allTransactions.filter(tx => tx.type !== 'nil');\n\n  return [{\n    date: currentDate,\n    xirr: Math.round(xirrValue * 10000) / 10000, // Round to 4 decimal places for precision\n    transactions: transactionsToReturn,\n    volatility: Math.round(volatility * 10000) / 10000 // Round to 4 decimal places for precision\n  }];\n}\n\n/**\n * Recalculate transactions for a specific date with nil transactions included\n * Used for on-demand calculation when viewing transaction details in modal\n * \n * @param navDataList - Array of NAV data for each fund\n * @param targetDate - The specific date to recalculate for\n * @param years - Rolling period in years\n * @param allocations - Target allocation percentages for each fund\n * @param rebalancingEnabled - Whether rebalancing was enabled\n * @param rebalancingThreshold - Threshold percentage for rebalancing\n * @param stepUpEnabled - Whether step-up SIP was enabled\n * @param stepUpPercentage - Annual percentage increase for step-up\n * @param sipAmount - Monthly SIP amount\n * @returns Transaction array with nil transactions included, or null if calculation fails\n */\nexport function recalculateTransactionsForDate(\n  navDataList: NavEntry[][],\n  targetDate: Date,\n  years: number,\n  allocations: number[],\n  rebalancingEnabled: boolean,\n  rebalancingThreshold: number,\n  stepUpEnabled: boolean,\n  stepUpPercentage: number,\n  sipAmount: number\n): Transaction[] | null {\n  // Validate input\n  if (!isValidInput(navDataList)) return null;\n\n  // Prepare data\n  const months = years * 12;\n  const filledNavs = navDataList.map(ensureContinuousDates);\n  const fundDateMaps = filledNavs.map(buildDateMap);\n  const baseDates = getSortedDates(filledNavs[0]);\n  const firstDate = baseDates[0];\n\n  // Calculate transactions for the target date with nil included\n  const allTransactions = calculateTransactionsForDate(\n    targetDate,\n    fundDateMaps,\n    months,\n    firstDate,\n    allocations,\n    rebalancingEnabled,\n    rebalancingThreshold,\n    stepUpEnabled,\n    stepUpPercentage,\n    sipAmount\n  );\n\n  return allTransactions;\n}\n"],"names":["areDatesContinuous","navData","sorted","a","b","i","prev","getNthPreviousMonthDate","currentDate","months","date","d","fillMissingNavDates","filled","current","last","sameDay","isValidInput","navDataList","f","ensureContinuousDates","fund","buildDateMap","entry","toDateKey","getSortedDates","generateSipDates","firstDate","sipDates","earliestSipDate","m","sipDate","getInvestmentYear","firstSipDate","yearsDiff","monthsDiff","createBuyTransactions","dateKey","fundDateMaps","allocations","state","stepUpEnabled","stepUpPercentage","sipAmount","totalInvestment","investmentYear","transactions","totalPortfolioValue","fundValues","fundIdx","investmentAmount","units","currentValue","tx","idx","createRebalanceTransactions","loopDate","rebalancingThreshold","portfolioValue","isRebalancingNeeded","rebalanceAmount","rebalanceUnits","cumulativeUnits","threshold","currentAllocation","targetAllocation","createNilTransactions","createFinalSellTransactions","unitsPerFund","sells","amount","calculateTransactionsForDate","rebalancingEnabled","initializeState","buildDailyTransactions","sellTransactions","numFunds","startDate","endDate","result","processSipDate","processNilDate","buyResult","rebalanceTransactions","newtonRaphsonMethod","newtonRaphson","fp","x0","options","x1","y","yp","tol","maxIter","iter","yph","ymh","yp2h","ym2h","h","hr","verbose","eps","newton","require$$0","MILLIS_PER_DAY","DAYS_IN_YEAR","convert","data","investments","start","end","minAmount","maxAmount","total","deposits","datum","epochDays","investment","xirr","value","rate","sum","A","Y","derivative","guess","xirr_1","calculateXirrFromTransactions","cashflows","aggregateCashflows","calculateXirr","cashflowsMap","currentAmount","dateStr","error","calculateDailySipPortfolioValue","relevantTransactions","transactionsByDate","groupTransactionsByDate","dailyValues","txs","totalValue","calculateTotalValue","cashFlow","calculateCashFlow","map","TRADING_DAYS_PER_YEAR","calculateVolatility","dailyReturns","calculateDailyReturns","meanReturn","r","variance","diff","dailyVolatility","totalDays","tradingDays","tradingDaysPerYear","returns","previousEntry","currentEntry","valueChange","marketReturn","calculateVolatilityForEntry","calculateSipRollingXirr","years","includeNilTransactions","filledNavs","baseDates","computeSipXirrForDate","allTransactions","xirrValue","volatility","transactionsToReturn","recalculateTransactionsForDate","targetDate"],"mappings":"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","x_google_ignoreList":[8,9]}